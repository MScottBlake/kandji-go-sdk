/*
Kandji API

<html><head></head><body><h1 id=&quot;welcome-to-the-kandji-api-documentation&quot;>Welcome to the Kandji API Documentation</h1> <p>You can find your API URL in Settings &gt; Access. The API URL will follow the below formats.</p> <ul> <li><p>US - <code>https://SubDomain.api.kandji.io</code></p> </li> <li><p>EU - <code>https://SubDomain.api.eu.kandji.io</code></p> </li> </ul> <p>For information on how to obtain an API token, please refer to the following support article.</p> <p><a href=&quot;https://support.kandji.io/api&quot;>https://support.kandji.io/api</a></p> <h4 id=&quot;rate-limit&quot;>Rate Limit</h4> <p>The Kandji API currently has an API rate limit of 10,000 requests per hour per customer.</p> <h4 id=&quot;request-methods&quot;>Request Methods</h4> <p>HTTP request methods supported by the Kandji API.</p> <div class=&quot;click-to-expand-wrapper is-table-wrapper&quot;><table> <thead> <tr> <th>Method</th> <th>Definition</th> </tr> </thead> <tbody> <tr> <td>GET</td> <td>The <code>GET</code> method requests a representation of the specified resource.</td> </tr> <tr> <td>POST</td> <td>The <code>POST</code> method submits an entity to the specified resource.</td> </tr> <tr> <td>PATCH</td> <td>The <code>PATCH</code> method applies partial modifications to a resource.</td> </tr> <tr> <td>DELETE</td> <td>The <code>DELETE</code> method deletes the specified resource.</td> </tr> </tbody> </table> </div><h4 id=&quot;response-codes&quot;>Response codes</h4> <p>Not all response codes apply to every endpoint.</p> <div class=&quot;click-to-expand-wrapper is-table-wrapper&quot;><table> <thead> <tr> <th>Code</th> <th>Response</th> </tr> </thead> <tbody> <tr> <td>200</td> <td>OK</td> </tr> <tr> <td>201</td> <td>Created</td> </tr> <tr> <td>204</td> <td>No content</td> </tr> <tr> <td></td> <td>Typical response when sending the DELETE method.</td> </tr> <tr> <td>400</td> <td>Bad Request</td> </tr> <tr> <td></td> <td>&quot;Command already running&quot; - The command may already be running in a <em>Pending</em> state waiting on the device.</td> </tr> <tr> <td></td> <td>&quot;Command is not allowed for current device&quot; - The command may not be compatible with the target device.</td> </tr> <tr> <td></td> <td>&quot;JSON parse error - Expecting ',' delimiter: line 3 column 2 (char 65)&quot;</td> </tr> <tr> <td>401</td> <td>Unauthorized</td> </tr> <tr> <td></td> <td>This error can occur if the token is incorrect, was revoked, or the token has expired.</td> </tr> <tr> <td>403</td> <td>Forbidden</td> </tr> <tr> <td></td> <td>The request was understood but cannot be authorized.</td> </tr> <tr> <td>404</td> <td>Not found</td> </tr> <tr> <td></td> <td>Unable to locate the resource in the Kandji tenant.</td> </tr> <tr> <td>415</td> <td>Unsupported Media Type</td> </tr> <tr> <td></td> <td>The request contains a media type which the server or resource does not support.</td> </tr> <tr> <td>500</td> <td>Internal server error</td> </tr> <tr> <td>503</td> <td>Service unavailable</td> </tr> <tr> <td></td> <td>This error can occur if a file upload is still being processed via the custom apps API.</td> </tr> </tbody> </table> </div><h4 id=&quot;data-structure&quot;>Data structure</h4> <p>The API returns all structured responses in JSON schema format.</p> <h4 id=&quot;examples&quot;>Examples</h4> <p>Code examples using the API can be found in the Kandji support <a href=&quot;https://github.com/kandji-inc/support/tree/main/api-tools&quot;>GitHub</a>.</p> </body></html>

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package kandji_sdk

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// PrismAPIService PrismAPI service
type PrismAPIService service

type ApiActivationLockRequest struct {
	ctx context.Context
	ApiService *PrismAPIService
	blueprintIds *string
	deviceFamilies *string
	filter *string
	sortBy *string
	limit *string
	offset *string
}

// Filter results by one or more blueprint IDs separated by commas.
func (r ApiActivationLockRequest) BlueprintIds(blueprintIds string) ApiActivationLockRequest {
	r.blueprintIds = &blueprintIds
	return r
}

// Filter results by one or more device families separate by commas.
func (r ApiActivationLockRequest) DeviceFamilies(deviceFamilies string) ApiActivationLockRequest {
	r.deviceFamilies = &deviceFamilies
	return r
}

// JSON schema object containing one or more key value pairs. Note: For detailed information on fiters, see the Filters section at the begining of the Visibility API endpoints in this doc.
func (r ApiActivationLockRequest) Filter(filter string) ApiActivationLockRequest {
	r.filter = &filter
	return r
}

// Sort results by the name of a given response body key in either ascending (default behavior) or descending(&lt;code&gt;-&lt;/code&gt;) order.
func (r ApiActivationLockRequest) SortBy(sortBy string) ApiActivationLockRequest {
	r.sortBy = &sortBy
	return r
}

// A hard upper &lt;code&gt;limit&lt;/code&gt; is set at 300 device records returned per request. If more device records are expected, pagination should be used using the &lt;code&gt;limit&lt;/code&gt; and &lt;code&gt;offset&lt;/code&gt; parameters. Additionally, parameter queries can be added to a request to limit the results.
func (r ApiActivationLockRequest) Limit(limit string) ApiActivationLockRequest {
	r.limit = &limit
	return r
}

// Specify the starting record to return.
func (r ApiActivationLockRequest) Offset(offset string) ApiActivationLockRequest {
	r.offset = &offset
	return r
}

func (r ApiActivationLockRequest) Execute() (*http.Response, error) {
	return r.ApiService.ActivationLockExecute(r)
}

/*
ActivationLock Activation lock

Get activation lock attributes for devices.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiActivationLockRequest
*/
func (a *PrismAPIService) ActivationLock(ctx context.Context) ApiActivationLockRequest {
	return ApiActivationLockRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *PrismAPIService) ActivationLockExecute(r ApiActivationLockRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PrismAPIService.ActivationLock")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/prism/activation_lock"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.blueprintIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blueprint_ids", r.blueprintIds, "form", "")
	}
	if r.deviceFamilies != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "device_families", r.deviceFamilies, "form", "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", r.sortBy, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApplicationFirewallRequest struct {
	ctx context.Context
	ApiService *PrismAPIService
	blueprintIds *string
	deviceFamilies *string
	filter *string
	sortBy *string
	limit *string
	offset *string
}

// Filter results by one or more blueprint IDs separated by commas.
func (r ApiApplicationFirewallRequest) BlueprintIds(blueprintIds string) ApiApplicationFirewallRequest {
	r.blueprintIds = &blueprintIds
	return r
}

// Filter results by one or more device families separate by commas.
func (r ApiApplicationFirewallRequest) DeviceFamilies(deviceFamilies string) ApiApplicationFirewallRequest {
	r.deviceFamilies = &deviceFamilies
	return r
}

// JSON schema object containing one or more key value pairs. Note: For detailed information on fiters, see the Filters section at the begining of the Visibility API endpoints in this doc.
func (r ApiApplicationFirewallRequest) Filter(filter string) ApiApplicationFirewallRequest {
	r.filter = &filter
	return r
}

// Sort results by the name of a given response body key in either ascending (default behavior) or descending(&lt;code&gt;-&lt;/code&gt;) order.
func (r ApiApplicationFirewallRequest) SortBy(sortBy string) ApiApplicationFirewallRequest {
	r.sortBy = &sortBy
	return r
}

// A hard upper &lt;code&gt;limit&lt;/code&gt; is set at 300 device records returned per request. If more device records are expected, pagination should be used using the &lt;code&gt;limit&lt;/code&gt; and &lt;code&gt;offset&lt;/code&gt; parameters. Additionally, parameter queries can be added to a request to limit the results.
func (r ApiApplicationFirewallRequest) Limit(limit string) ApiApplicationFirewallRequest {
	r.limit = &limit
	return r
}

// Specify the starting record to return.
func (r ApiApplicationFirewallRequest) Offset(offset string) ApiApplicationFirewallRequest {
	r.offset = &offset
	return r
}

func (r ApiApplicationFirewallRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ApplicationFirewallExecute(r)
}

/*
ApplicationFirewall Application firewall

Get Application Firewall details for macOS.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApplicationFirewallRequest
*/
func (a *PrismAPIService) ApplicationFirewall(ctx context.Context) ApiApplicationFirewallRequest {
	return ApiApplicationFirewallRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *PrismAPIService) ApplicationFirewallExecute(r ApiApplicationFirewallRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PrismAPIService.ApplicationFirewall")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/prism/application_firewall"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.blueprintIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blueprint_ids", r.blueprintIds, "form", "")
	}
	if r.deviceFamilies != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "device_families", r.deviceFamilies, "form", "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", r.sortBy, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApplicationsRequest struct {
	ctx context.Context
	ApiService *PrismAPIService
	blueprintIds *string
	deviceFamilies *string
	filter *string
	sortBy *string
	limit *string
	offset *string
}

// Filter results by one or more blueprint IDs separated by commas.
func (r ApiApplicationsRequest) BlueprintIds(blueprintIds string) ApiApplicationsRequest {
	r.blueprintIds = &blueprintIds
	return r
}

// Filter results by one or more device families separate by commas.
func (r ApiApplicationsRequest) DeviceFamilies(deviceFamilies string) ApiApplicationsRequest {
	r.deviceFamilies = &deviceFamilies
	return r
}

// JSON schema object containing one or more key value pairs. Note: For detailed information on fiters, see the Filters section at the begining of the Visibility API endpoints in this doc.
func (r ApiApplicationsRequest) Filter(filter string) ApiApplicationsRequest {
	r.filter = &filter
	return r
}

// Sort results by the name of a given response body key in either ascending (default behavior) or descending(&lt;code&gt;-&lt;/code&gt;) order.
func (r ApiApplicationsRequest) SortBy(sortBy string) ApiApplicationsRequest {
	r.sortBy = &sortBy
	return r
}

// A hard upper &lt;code&gt;limit&lt;/code&gt; is set at 300 device records returned per request. If more device records are expected, pagination should be used using the &lt;code&gt;limit&lt;/code&gt; and &lt;code&gt;offset&lt;/code&gt; parameters. Additionally, parameter queries can be added to a request to limit the results.
func (r ApiApplicationsRequest) Limit(limit string) ApiApplicationsRequest {
	r.limit = &limit
	return r
}

// Specify the starting record to return.
func (r ApiApplicationsRequest) Offset(offset string) ApiApplicationsRequest {
	r.offset = &offset
	return r
}

func (r ApiApplicationsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ApplicationsExecute(r)
}

/*
Applications Applications

Get the applications installed on macOS, iOS, iPadOS, and tvOS devices.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApplicationsRequest
*/
func (a *PrismAPIService) Applications(ctx context.Context) ApiApplicationsRequest {
	return ApiApplicationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *PrismAPIService) ApplicationsExecute(r ApiApplicationsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PrismAPIService.Applications")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/prism/apps"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.blueprintIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blueprint_ids", r.blueprintIds, "form", "")
	}
	if r.deviceFamilies != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "device_families", r.deviceFamilies, "form", "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", r.sortBy, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCertificatesRequest struct {
	ctx context.Context
	ApiService *PrismAPIService
	blueprintIds *string
	deviceFamilies *string
	filter *string
	sortBy *string
	limit *string
	offset *string
}

// Filter results by one or more blueprint IDs separated by commas.
func (r ApiCertificatesRequest) BlueprintIds(blueprintIds string) ApiCertificatesRequest {
	r.blueprintIds = &blueprintIds
	return r
}

// Filter results by one or more device families separate by commas.
func (r ApiCertificatesRequest) DeviceFamilies(deviceFamilies string) ApiCertificatesRequest {
	r.deviceFamilies = &deviceFamilies
	return r
}

// JSON schema object containing one or more key value pairs. Note: For detailed information on fiters, see the Filters section at the begining of the Visibility API endpoints in this doc.
func (r ApiCertificatesRequest) Filter(filter string) ApiCertificatesRequest {
	r.filter = &filter
	return r
}

// Sort results by the name of a given response body key in either ascending (default behavior) or descending(&lt;code&gt;-&lt;/code&gt;) order.
func (r ApiCertificatesRequest) SortBy(sortBy string) ApiCertificatesRequest {
	r.sortBy = &sortBy
	return r
}

// A hard upper &lt;code&gt;limit&lt;/code&gt; is set at 300 device records returned per request. If more device records are expected, pagination should be used using the &lt;code&gt;limit&lt;/code&gt; and &lt;code&gt;offset&lt;/code&gt; parameters. Additionally, parameter queries can be added to a request to limit the results.
func (r ApiCertificatesRequest) Limit(limit string) ApiCertificatesRequest {
	r.limit = &limit
	return r
}

// Specify the starting record to return.
func (r ApiCertificatesRequest) Offset(offset string) ApiCertificatesRequest {
	r.offset = &offset
	return r
}

func (r ApiCertificatesRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CertificatesExecute(r)
}

/*
Certificates Certificates

Get certificate details.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCertificatesRequest
*/
func (a *PrismAPIService) Certificates(ctx context.Context) ApiCertificatesRequest {
	return ApiCertificatesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *PrismAPIService) CertificatesExecute(r ApiCertificatesRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PrismAPIService.Certificates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/prism/certificates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.blueprintIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blueprint_ids", r.blueprintIds, "form", "")
	}
	if r.deviceFamilies != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "device_families", r.deviceFamilies, "form", "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", r.sortBy, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCountRequest struct {
	ctx context.Context
	ApiService *PrismAPIService
	category *string
}

// &lt;p&gt;Return the count of records for the specified category.  If a category contains spaces substitute the spaces for underscores (&amp;quot;_&amp;quot;) when using the API query.&lt;/p&gt; &lt;p&gt;Examples: apps device_information kernel_extensions system_extensions&lt;/p&gt;
func (r ApiCountRequest) Category(category string) ApiCountRequest {
	r.category = &category
	return r
}

func (r ApiCountRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CountExecute(r)
}

/*
Count Count

<p>Get the total record count for the specified Prism category.</p>
<p>If a category contains spaces substitute the spaces for underscores (&quot;_&quot;) when using the API query.</p>
<p>Example: <code>Device information</code> becomes <code>device_information</code>.</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCountRequest
*/
func (a *PrismAPIService) Count(ctx context.Context) ApiCountRequest {
	return ApiCountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *PrismAPIService) CountExecute(r ApiCountRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PrismAPIService.Count")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/prism/count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.category == nil {
		return localVarReturnValue, nil, reportError("category is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "category", r.category, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDesktopAndScreensaverRequest struct {
	ctx context.Context
	ApiService *PrismAPIService
	blueprintIds *string
	deviceFamilies *string
	filter *string
	sortBy *string
	limit *string
	offset *string
}

// Filter results by one or more blueprint IDs separated by commas.
func (r ApiDesktopAndScreensaverRequest) BlueprintIds(blueprintIds string) ApiDesktopAndScreensaverRequest {
	r.blueprintIds = &blueprintIds
	return r
}

// Filter results by one or more device families separate by commas.
func (r ApiDesktopAndScreensaverRequest) DeviceFamilies(deviceFamilies string) ApiDesktopAndScreensaverRequest {
	r.deviceFamilies = &deviceFamilies
	return r
}

// JSON schema object containing one or more key value pairs. Note: For detailed information on fiters, see the Filters section at the begining of the Visibility API endpoints in this doc.
func (r ApiDesktopAndScreensaverRequest) Filter(filter string) ApiDesktopAndScreensaverRequest {
	r.filter = &filter
	return r
}

// Sort results by the name of a given response body key in either ascending (default behavior) or descending(&lt;code&gt;-&lt;/code&gt;) order.
func (r ApiDesktopAndScreensaverRequest) SortBy(sortBy string) ApiDesktopAndScreensaverRequest {
	r.sortBy = &sortBy
	return r
}

// A hard upper &lt;code&gt;limit&lt;/code&gt; is set at 300 device records returned per request. If more device records are expected, pagination should be used using the &lt;code&gt;limit&lt;/code&gt; and &lt;code&gt;offset&lt;/code&gt; parameters. Additionally, parameter queries can be added to a request to limit the results.
func (r ApiDesktopAndScreensaverRequest) Limit(limit string) ApiDesktopAndScreensaverRequest {
	r.limit = &limit
	return r
}

// Specify the starting record to return.
func (r ApiDesktopAndScreensaverRequest) Offset(offset string) ApiDesktopAndScreensaverRequest {
	r.offset = &offset
	return r
}

func (r ApiDesktopAndScreensaverRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DesktopAndScreensaverExecute(r)
}

/*
DesktopAndScreensaver Desktop and Screensaver

Get Desktop and Screensaver details for macOS.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDesktopAndScreensaverRequest
*/
func (a *PrismAPIService) DesktopAndScreensaver(ctx context.Context) ApiDesktopAndScreensaverRequest {
	return ApiDesktopAndScreensaverRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *PrismAPIService) DesktopAndScreensaverExecute(r ApiDesktopAndScreensaverRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PrismAPIService.DesktopAndScreensaver")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/prism/desktop_and_screensaver"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.blueprintIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blueprint_ids", r.blueprintIds, "form", "")
	}
	if r.deviceFamilies != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "device_families", r.deviceFamilies, "form", "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", r.sortBy, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeviceInformationRequest struct {
	ctx context.Context
	ApiService *PrismAPIService
	blueprintIds *string
	deviceFamilies *string
	filter *string
	sortBy *string
	limit *string
	offset *string
	body *string
}

// Filter results by one or more blueprint IDs separated by commas.
func (r ApiDeviceInformationRequest) BlueprintIds(blueprintIds string) ApiDeviceInformationRequest {
	r.blueprintIds = &blueprintIds
	return r
}

// Filter results by one or more device families separate by commas.
func (r ApiDeviceInformationRequest) DeviceFamilies(deviceFamilies string) ApiDeviceInformationRequest {
	r.deviceFamilies = &deviceFamilies
	return r
}

// &lt;p&gt;JSON schema object containing one or more key value pairs.&lt;/p&gt; &lt;p&gt;Note: For detailed information on fiters, see the Filters section at the begining of the Visibility API endpoints in this doc.&lt;/p&gt;
func (r ApiDeviceInformationRequest) Filter(filter string) ApiDeviceInformationRequest {
	r.filter = &filter
	return r
}

// Sort results by the name of a given response body key in either ascending (default behavior) or descending(&lt;code&gt;-&lt;/code&gt;) order.
func (r ApiDeviceInformationRequest) SortBy(sortBy string) ApiDeviceInformationRequest {
	r.sortBy = &sortBy
	return r
}

// A hard upper &lt;code&gt;limit&lt;/code&gt; is set at 300 device records returned per request. If more device records are expected, pagination should be used using the &lt;code&gt;limit&lt;/code&gt; and &lt;code&gt;offset&lt;/code&gt; parameters. Additionally, parameter queries can be added to a request to limit the results.
func (r ApiDeviceInformationRequest) Limit(limit string) ApiDeviceInformationRequest {
	r.limit = &limit
	return r
}

// Specify the starting record to return
func (r ApiDeviceInformationRequest) Offset(offset string) ApiDeviceInformationRequest {
	r.offset = &offset
	return r
}

func (r ApiDeviceInformationRequest) Body(body string) ApiDeviceInformationRequest {
	r.body = &body
	return r
}

func (r ApiDeviceInformationRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DeviceInformationExecute(r)
}

/*
DeviceInformation Device information

Get attributes about devices.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeviceInformationRequest
*/
func (a *PrismAPIService) DeviceInformation(ctx context.Context) ApiDeviceInformationRequest {
	return ApiDeviceInformationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *PrismAPIService) DeviceInformationExecute(r ApiDeviceInformationRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PrismAPIService.DeviceInformation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/prism/device_information"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.blueprintIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blueprint_ids", r.blueprintIds, "form", "")
	}
	if r.deviceFamilies != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "device_families", r.deviceFamilies, "form", "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", r.sortBy, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFilevaultRequest struct {
	ctx context.Context
	ApiService *PrismAPIService
	blueprintIds *string
	deviceFamilies *string
	filter *string
	sortBy *string
	limit *string
	offset *string
}

// Filter results by one or more blueprint IDs separated by commas.
func (r ApiFilevaultRequest) BlueprintIds(blueprintIds string) ApiFilevaultRequest {
	r.blueprintIds = &blueprintIds
	return r
}

// Filter results by one or more device families separate by commas.
func (r ApiFilevaultRequest) DeviceFamilies(deviceFamilies string) ApiFilevaultRequest {
	r.deviceFamilies = &deviceFamilies
	return r
}

// JSON schema object containing one or more key value pairs. Note: For detailed information on fiters, see the Filters section at the begining of the Visibility API endpoints in this doc.
func (r ApiFilevaultRequest) Filter(filter string) ApiFilevaultRequest {
	r.filter = &filter
	return r
}

// Sort results by the name of a given response body key in either ascending (default behavior) or descending(&lt;code&gt;-&lt;/code&gt;) order.
func (r ApiFilevaultRequest) SortBy(sortBy string) ApiFilevaultRequest {
	r.sortBy = &sortBy
	return r
}

// A hard upper &lt;code&gt;limit&lt;/code&gt; is set at 300 device records returned per request. If more device records are expected, pagination should be used using the &lt;code&gt;limit&lt;/code&gt; and &lt;code&gt;offset&lt;/code&gt; parameters. Additionally, parameter queries can be added to a request to limit the results.
func (r ApiFilevaultRequest) Limit(limit string) ApiFilevaultRequest {
	r.limit = &limit
	return r
}

// Specify the starting record to return
func (r ApiFilevaultRequest) Offset(offset string) ApiFilevaultRequest {
	r.offset = &offset
	return r
}

func (r ApiFilevaultRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.FilevaultExecute(r)
}

/*
Filevault FileVault

Get FileVault information for macOS.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFilevaultRequest
*/
func (a *PrismAPIService) Filevault(ctx context.Context) ApiFilevaultRequest {
	return ApiFilevaultRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *PrismAPIService) FilevaultExecute(r ApiFilevaultRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PrismAPIService.Filevault")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/prism/filevault"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.blueprintIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blueprint_ids", r.blueprintIds, "form", "")
	}
	if r.deviceFamilies != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "device_families", r.deviceFamilies, "form", "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", r.sortBy, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGatekeeperAndXprotectRequest struct {
	ctx context.Context
	ApiService *PrismAPIService
	blueprintIds *string
	deviceFamilies *string
	filter *string
	sortBy *string
	limit *string
	offset *string
}

// Filter results by one or more blueprint IDs separated by commas.
func (r ApiGatekeeperAndXprotectRequest) BlueprintIds(blueprintIds string) ApiGatekeeperAndXprotectRequest {
	r.blueprintIds = &blueprintIds
	return r
}

// Results are limited to Mac only as Gatekeeper and XProtect are not applicable for other platfroms.
func (r ApiGatekeeperAndXprotectRequest) DeviceFamilies(deviceFamilies string) ApiGatekeeperAndXprotectRequest {
	r.deviceFamilies = &deviceFamilies
	return r
}

// JSON schema object containing one or more key value pairs. Note: For detailed information on fiters, see the Filters section at the begining of the Visibility API endpoints in this doc.
func (r ApiGatekeeperAndXprotectRequest) Filter(filter string) ApiGatekeeperAndXprotectRequest {
	r.filter = &filter
	return r
}

// Sort results by the name of a given response body key in either ascending (default behavior) or descending(&lt;code&gt;-&lt;/code&gt;) order.
func (r ApiGatekeeperAndXprotectRequest) SortBy(sortBy string) ApiGatekeeperAndXprotectRequest {
	r.sortBy = &sortBy
	return r
}

// A hard upper &lt;code&gt;limit&lt;/code&gt; is set at 300 device records returned per request. If more device records are expected, pagination should be used using the &lt;code&gt;limit&lt;/code&gt; and &lt;code&gt;offset&lt;/code&gt; parameters. Additionally, parameter queries can be added to a request to limit the results.
func (r ApiGatekeeperAndXprotectRequest) Limit(limit string) ApiGatekeeperAndXprotectRequest {
	r.limit = &limit
	return r
}

// Specify the starting record to return
func (r ApiGatekeeperAndXprotectRequest) Offset(offset string) ApiGatekeeperAndXprotectRequest {
	r.offset = &offset
	return r
}

func (r ApiGatekeeperAndXprotectRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GatekeeperAndXprotectExecute(r)
}

/*
GatekeeperAndXprotect Gatekeeper and XProtect

Get Gatekeeper and XProtect attributes for macOS.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGatekeeperAndXprotectRequest
*/
func (a *PrismAPIService) GatekeeperAndXprotect(ctx context.Context) ApiGatekeeperAndXprotectRequest {
	return ApiGatekeeperAndXprotectRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *PrismAPIService) GatekeeperAndXprotectExecute(r ApiGatekeeperAndXprotectRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PrismAPIService.GatekeeperAndXprotect")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/prism/gatekeeper_and_xprotect"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.blueprintIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blueprint_ids", r.blueprintIds, "form", "")
	}
	if r.deviceFamilies != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "device_families", r.deviceFamilies, "form", "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", r.sortBy, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCategoryExportRequest struct {
	ctx context.Context
	ApiService *PrismAPIService
	exportId string
}

func (r ApiGetCategoryExportRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetCategoryExportExecute(r)
}

/*
GetCategoryExport Get category export

<p>Get an export request's status. To download the export, use the <code>signed_url</code>. This will download a CSV file containing the exported category information.</p>
<h3 id=&quot;request-parameters&quot;>Request Parameters</h3>
<p>export_id (path parameter): The unique identifier of the the export job.</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param exportId
 @return ApiGetCategoryExportRequest
*/
func (a *PrismAPIService) GetCategoryExport(ctx context.Context, exportId string) ApiGetCategoryExportRequest {
	return ApiGetCategoryExportRequest{
		ApiService: a,
		ctx: ctx,
		exportId: exportId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *PrismAPIService) GetCategoryExportExecute(r ApiGetCategoryExportRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PrismAPIService.GetCategoryExport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/prism/export/{export_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"export_id"+"}", url.PathEscape(parameterValueToString(r.exportId, "exportId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInstalledProfilesRequest struct {
	ctx context.Context
	ApiService *PrismAPIService
	blueprintIds *string
	deviceFamilies *string
	filter *string
	sortBy *string
	limit *string
	offset *string
}

// Filter results by one or more blueprint IDs separated by commas.
func (r ApiInstalledProfilesRequest) BlueprintIds(blueprintIds string) ApiInstalledProfilesRequest {
	r.blueprintIds = &blueprintIds
	return r
}

// Filter results by one or more device families separate by commas.
func (r ApiInstalledProfilesRequest) DeviceFamilies(deviceFamilies string) ApiInstalledProfilesRequest {
	r.deviceFamilies = &deviceFamilies
	return r
}

// JSON schema object containing one or more key value pairs. Note: For detailed information on fiters, see the Filters section at the begining of the Visibility API endpoints in this doc.
func (r ApiInstalledProfilesRequest) Filter(filter string) ApiInstalledProfilesRequest {
	r.filter = &filter
	return r
}

// Sort results by the name of a given response body key in either ascending (default behavior) or descending(&lt;code&gt;-&lt;/code&gt;) order.
func (r ApiInstalledProfilesRequest) SortBy(sortBy string) ApiInstalledProfilesRequest {
	r.sortBy = &sortBy
	return r
}

// A hard upper &lt;code&gt;limit&lt;/code&gt; is set at 300 device records returned per request. If more device records are expected, pagination should be used using the &lt;code&gt;limit&lt;/code&gt; and &lt;code&gt;offset&lt;/code&gt; parameters. Additionally, parameter queries can be added to a request to limit the results.
func (r ApiInstalledProfilesRequest) Limit(limit string) ApiInstalledProfilesRequest {
	r.limit = &limit
	return r
}

// Specify the starting record to return.
func (r ApiInstalledProfilesRequest) Offset(offset string) ApiInstalledProfilesRequest {
	r.offset = &offset
	return r
}

func (r ApiInstalledProfilesRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.InstalledProfilesExecute(r)
}

/*
InstalledProfiles Installed profiles

Get Installed Profiles attributes for macOS, iOS, iPadOS, and tvOS.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiInstalledProfilesRequest
*/
func (a *PrismAPIService) InstalledProfiles(ctx context.Context) ApiInstalledProfilesRequest {
	return ApiInstalledProfilesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *PrismAPIService) InstalledProfilesExecute(r ApiInstalledProfilesRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PrismAPIService.InstalledProfiles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/prism/installed_profiles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.blueprintIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blueprint_ids", r.blueprintIds, "form", "")
	}
	if r.deviceFamilies != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "device_families", r.deviceFamilies, "form", "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", r.sortBy, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiKernelExtensionsRequest struct {
	ctx context.Context
	ApiService *PrismAPIService
	blueprintIds *string
	deviceFamilies *string
	filter *string
	sortBy *string
	limit *string
	offset *string
}

// Filter results by one or more blueprint IDs separated by commas.
func (r ApiKernelExtensionsRequest) BlueprintIds(blueprintIds string) ApiKernelExtensionsRequest {
	r.blueprintIds = &blueprintIds
	return r
}

// Filter results by one or more device families separate by commas.
func (r ApiKernelExtensionsRequest) DeviceFamilies(deviceFamilies string) ApiKernelExtensionsRequest {
	r.deviceFamilies = &deviceFamilies
	return r
}

// SON schema object containing one or more key value pairs. Note: For detailed information on fiters, see the Filters section at the begining of the Visibility API endpoints in this doc.
func (r ApiKernelExtensionsRequest) Filter(filter string) ApiKernelExtensionsRequest {
	r.filter = &filter
	return r
}

// Sort results by the name of a given response body key in either ascending (default behavior) or descending(&lt;code&gt;-&lt;/code&gt;) order.
func (r ApiKernelExtensionsRequest) SortBy(sortBy string) ApiKernelExtensionsRequest {
	r.sortBy = &sortBy
	return r
}

// A hard upper &lt;code&gt;limit&lt;/code&gt; is set at 300 device records returned per request. If more device records are expected, pagination should be used using the &lt;code&gt;limit&lt;/code&gt; and &lt;code&gt;offset&lt;/code&gt; parameters. Additionally, parameter queries can be added to a request to limit the results.
func (r ApiKernelExtensionsRequest) Limit(limit string) ApiKernelExtensionsRequest {
	r.limit = &limit
	return r
}

// Specify the starting record to return.
func (r ApiKernelExtensionsRequest) Offset(offset string) ApiKernelExtensionsRequest {
	r.offset = &offset
	return r
}

func (r ApiKernelExtensionsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.KernelExtensionsExecute(r)
}

/*
KernelExtensions Kernel Extensions

Get Kernel Extension attributes for macOS.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiKernelExtensionsRequest
*/
func (a *PrismAPIService) KernelExtensions(ctx context.Context) ApiKernelExtensionsRequest {
	return ApiKernelExtensionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *PrismAPIService) KernelExtensionsExecute(r ApiKernelExtensionsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PrismAPIService.KernelExtensions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/prism/kernel_extensions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.blueprintIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blueprint_ids", r.blueprintIds, "form", "")
	}
	if r.deviceFamilies != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "device_families", r.deviceFamilies, "form", "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", r.sortBy, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLaunchAgentsAndDaemonsRequest struct {
	ctx context.Context
	ApiService *PrismAPIService
	blueprintIds *string
	deviceFamilies *string
	filter *string
	sortBy *string
	limit *string
	offset *string
}

// Filter results by one or more blueprint IDs separated by commas.
func (r ApiLaunchAgentsAndDaemonsRequest) BlueprintIds(blueprintIds string) ApiLaunchAgentsAndDaemonsRequest {
	r.blueprintIds = &blueprintIds
	return r
}

// Filter results by one or more device families separate by commas.
func (r ApiLaunchAgentsAndDaemonsRequest) DeviceFamilies(deviceFamilies string) ApiLaunchAgentsAndDaemonsRequest {
	r.deviceFamilies = &deviceFamilies
	return r
}

// JSON schema object containing one or more key value pairs. Note: For detailed information on fiters, see the Filters section at the begining of the Visibility API endpoints in this doc.
func (r ApiLaunchAgentsAndDaemonsRequest) Filter(filter string) ApiLaunchAgentsAndDaemonsRequest {
	r.filter = &filter
	return r
}

// Sort results by the name of a given response body key in either ascending (default behavior) or descending(&lt;code&gt;-&lt;/code&gt;) order.
func (r ApiLaunchAgentsAndDaemonsRequest) SortBy(sortBy string) ApiLaunchAgentsAndDaemonsRequest {
	r.sortBy = &sortBy
	return r
}

// A hard upper &lt;code&gt;limit&lt;/code&gt; is set at 300 device records returned per request. If more device records are expected, pagination should be used using the &lt;code&gt;limit&lt;/code&gt; and &lt;code&gt;offset&lt;/code&gt; parameters. Additionally, parameter queries can be added to a request to limit the results.
func (r ApiLaunchAgentsAndDaemonsRequest) Limit(limit string) ApiLaunchAgentsAndDaemonsRequest {
	r.limit = &limit
	return r
}

// Specify the starting record to return.
func (r ApiLaunchAgentsAndDaemonsRequest) Offset(offset string) ApiLaunchAgentsAndDaemonsRequest {
	r.offset = &offset
	return r
}

func (r ApiLaunchAgentsAndDaemonsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.LaunchAgentsAndDaemonsExecute(r)
}

/*
LaunchAgentsAndDaemons Launch Agents and Daemons

Get Launch Agents and Daemons installed on macOS.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLaunchAgentsAndDaemonsRequest
*/
func (a *PrismAPIService) LaunchAgentsAndDaemons(ctx context.Context) ApiLaunchAgentsAndDaemonsRequest {
	return ApiLaunchAgentsAndDaemonsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *PrismAPIService) LaunchAgentsAndDaemonsExecute(r ApiLaunchAgentsAndDaemonsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PrismAPIService.LaunchAgentsAndDaemons")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/prism/launch_agents_and_daemons"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.blueprintIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blueprint_ids", r.blueprintIds, "form", "")
	}
	if r.deviceFamilies != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "device_families", r.deviceFamilies, "form", "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", r.sortBy, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLocalUsersRequest struct {
	ctx context.Context
	ApiService *PrismAPIService
	blueprintIds *string
	deviceFamilies *string
	filter *string
	sortBy *string
	limit *string
	offset *string
}

// Filter results by one or more blueprint IDs separated by commas.
func (r ApiLocalUsersRequest) BlueprintIds(blueprintIds string) ApiLocalUsersRequest {
	r.blueprintIds = &blueprintIds
	return r
}

// Filter results by one or more device families separate by commas.
func (r ApiLocalUsersRequest) DeviceFamilies(deviceFamilies string) ApiLocalUsersRequest {
	r.deviceFamilies = &deviceFamilies
	return r
}

// JSON schema object containing one or more key value pairs. Note: For detailed information on fiters, see the Filters section at the begining of the Visibility API endpoints in this doc.
func (r ApiLocalUsersRequest) Filter(filter string) ApiLocalUsersRequest {
	r.filter = &filter
	return r
}

// Sort results by the name of a given response body key in either ascending (default behavior) or descending(&lt;code&gt;-&lt;/code&gt;) order.
func (r ApiLocalUsersRequest) SortBy(sortBy string) ApiLocalUsersRequest {
	r.sortBy = &sortBy
	return r
}

// A hard upper &lt;code&gt;limit&lt;/code&gt; is set at 300 device records returned per request. If more device records are expected, pagination should be used using the &lt;code&gt;limit&lt;/code&gt; and &lt;code&gt;offset&lt;/code&gt; parameters. Additionally, parameter queries can be added to a request to limit the results.
func (r ApiLocalUsersRequest) Limit(limit string) ApiLocalUsersRequest {
	r.limit = &limit
	return r
}

// Specify the starting record to return.
func (r ApiLocalUsersRequest) Offset(offset string) ApiLocalUsersRequest {
	r.offset = &offset
	return r
}

func (r ApiLocalUsersRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.LocalUsersExecute(r)
}

/*
LocalUsers Local users

Get Local Users detials for macOS.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLocalUsersRequest
*/
func (a *PrismAPIService) LocalUsers(ctx context.Context) ApiLocalUsersRequest {
	return ApiLocalUsersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *PrismAPIService) LocalUsersExecute(r ApiLocalUsersRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PrismAPIService.LocalUsers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/prism/local_users"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.blueprintIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blueprint_ids", r.blueprintIds, "form", "")
	}
	if r.deviceFamilies != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "device_families", r.deviceFamilies, "form", "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", r.sortBy, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRequestCategoryExportRequest struct {
	ctx context.Context
	ApiService *PrismAPIService
	body *string
}

func (r ApiRequestCategoryExportRequest) Body(body string) ApiRequestCategoryExportRequest {
	r.body = &body
	return r
}

func (r ApiRequestCategoryExportRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.RequestCategoryExportExecute(r)
}

/*
RequestCategoryExport Request category export

<p>Request export of a category. The <code>id</code> key is used when checking the export status using the <em>Request category export</em> endpoint.</p>
<p><strong>Request Body Parameters: application/json</strong></p>
<div class=&quot;click-to-expand-wrapper is-table-wrapper&quot;><table>
<thead>
<tr>
<th>Key</th>
<th>Type</th>
<th>Possible value(s)</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>blueprint_ids</code></td>
<td><code>array</code></td>
<td><code>[&quot;string&quot;, &quot;string&quot;, &quot;string&quot;]</code></td>
<td>List of one or more comma separate blueprint IDs.</td>
</tr>
<tr>
<td><code>category</code></td>
<td><code>string</code></td>
<td><code>apps</code> ,  <br /><code>activation_lock</code> ,  <br /><code>desktop_and_screensaver</code> ,  <br /><code>device_information</code> ,  <br /><code>gatekeeper_and_xprotect</code> ,  <br /><code>installed_profiles</code> ,  <br /><code>kernel_extensions</code> ,  <br /><code>local_users</code> ,  <br /><code>launch_agents_and_daemons</code> ,  <br /><code>system_extensions</code> ,  <br /><code>startup_settings</code> ,  <br /><code>transparency_database</code></td>
<td>Only one category per export reqest.</td>
</tr>
<tr>
<td><code>device_families</code></td>
<td><code>array</code></td>
<td><code>[&quot;Mac&quot;, &quot;iPhone&quot;, &quot;iPad&quot;, &quot;tvOS&quot;]</code></td>
<td>List of one or more comma separted string values for device families.</td>
</tr>
<tr>
<td><code>filter</code></td>
<td><code>object</code></td>
<td><code>{&quot;apple_silicon&quot;: {&quot;eq&quot;: true}, &quot;device__name&quot;: {&quot;like&quot;: [&quot;this&quot;, &quot;or_this&quot;]}}</code></td>
<td>JSON schema object containing one or more key value pairs.  <br />  <br /><strong>Note</strong>: For detailed information on fiters, see the Filters section at the begining of the Visibility API endpoints in this doc.</td>
</tr>
<tr>
<td><code>sort_by</code></td>
<td><code>string</code></td>
<td></td>
<td>Sort results by the name of a given response body key in either ascending (default behavior) or descending(`-`) order.</td>
</tr>
</tbody>
</table>
</div>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRequestCategoryExportRequest
*/
func (a *PrismAPIService) RequestCategoryExport(ctx context.Context) ApiRequestCategoryExportRequest {
	return ApiRequestCategoryExportRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *PrismAPIService) RequestCategoryExportExecute(r ApiRequestCategoryExportRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PrismAPIService.RequestCategoryExport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/prism/export"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStartupSettingsRequest struct {
	ctx context.Context
	ApiService *PrismAPIService
	blueprintIds *string
	deviceFamilies *string
	filter *string
	sortBy *string
	limit *string
	offset *string
}

// Filter results by one or more blueprint IDs separated by commas.
func (r ApiStartupSettingsRequest) BlueprintIds(blueprintIds string) ApiStartupSettingsRequest {
	r.blueprintIds = &blueprintIds
	return r
}

// Filter results by one or more device families separate by commas.
func (r ApiStartupSettingsRequest) DeviceFamilies(deviceFamilies string) ApiStartupSettingsRequest {
	r.deviceFamilies = &deviceFamilies
	return r
}

// JSON schema object containing one or more key value pairs. Note: For detailed information on fiters, see the Filters section at the begining of the Visibility API endpoints in this doc.
func (r ApiStartupSettingsRequest) Filter(filter string) ApiStartupSettingsRequest {
	r.filter = &filter
	return r
}

// Sort results by the name of a given response body key in either ascending (default behavior) or descending(&lt;code&gt;-&lt;/code&gt;) order.
func (r ApiStartupSettingsRequest) SortBy(sortBy string) ApiStartupSettingsRequest {
	r.sortBy = &sortBy
	return r
}

// A hard upper &lt;code&gt;limit&lt;/code&gt; is set at 300 device records returned per request. If more device records are expected, pagination should be used using the &lt;code&gt;limit&lt;/code&gt; and &lt;code&gt;offset&lt;/code&gt; parameters. Additionally, parameter queries can be added to a request to limit the results.
func (r ApiStartupSettingsRequest) Limit(limit string) ApiStartupSettingsRequest {
	r.limit = &limit
	return r
}

// Specify the starting record to return
func (r ApiStartupSettingsRequest) Offset(offset string) ApiStartupSettingsRequest {
	r.offset = &offset
	return r
}

func (r ApiStartupSettingsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.StartupSettingsExecute(r)
}

/*
StartupSettings Startup settings

Get Startup settings for macOS.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiStartupSettingsRequest
*/
func (a *PrismAPIService) StartupSettings(ctx context.Context) ApiStartupSettingsRequest {
	return ApiStartupSettingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *PrismAPIService) StartupSettingsExecute(r ApiStartupSettingsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PrismAPIService.StartupSettings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/prism/startup_settings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.blueprintIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blueprint_ids", r.blueprintIds, "form", "")
	}
	if r.deviceFamilies != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "device_families", r.deviceFamilies, "form", "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", r.sortBy, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSystemExtensionsRequest struct {
	ctx context.Context
	ApiService *PrismAPIService
	blueprintIds *string
	deviceFamilies *string
	filter *string
	sortBy *string
	limit *string
	offset *string
}

// Filter results by one or more blueprint IDs separated by commas.
func (r ApiSystemExtensionsRequest) BlueprintIds(blueprintIds string) ApiSystemExtensionsRequest {
	r.blueprintIds = &blueprintIds
	return r
}

// Filter results by one or more device families separate by commas.
func (r ApiSystemExtensionsRequest) DeviceFamilies(deviceFamilies string) ApiSystemExtensionsRequest {
	r.deviceFamilies = &deviceFamilies
	return r
}

// JSON schema object containing one or more key value pairs. Note: For detailed information on fiters, see the Filters section at the begining of the Visibility API endpoints in this doc.
func (r ApiSystemExtensionsRequest) Filter(filter string) ApiSystemExtensionsRequest {
	r.filter = &filter
	return r
}

// Sort results by the name of a given response body key in either ascending (default behavior) or descending(&lt;code&gt;-&lt;/code&gt;) order.
func (r ApiSystemExtensionsRequest) SortBy(sortBy string) ApiSystemExtensionsRequest {
	r.sortBy = &sortBy
	return r
}

// A hard upper &lt;code&gt;limit&lt;/code&gt; is set at 300 device records returned per request. If more device records are expected, pagination should be used using the &lt;code&gt;limit&lt;/code&gt; and &lt;code&gt;offset&lt;/code&gt; parameters. Additionally, parameter queries can be added to a request to limit the results.
func (r ApiSystemExtensionsRequest) Limit(limit string) ApiSystemExtensionsRequest {
	r.limit = &limit
	return r
}

// Specify the starting record to return.
func (r ApiSystemExtensionsRequest) Offset(offset string) ApiSystemExtensionsRequest {
	r.offset = &offset
	return r
}

func (r ApiSystemExtensionsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.SystemExtensionsExecute(r)
}

/*
SystemExtensions System Extensions

Get System Extension attributes for macOS.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSystemExtensionsRequest
*/
func (a *PrismAPIService) SystemExtensions(ctx context.Context) ApiSystemExtensionsRequest {
	return ApiSystemExtensionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *PrismAPIService) SystemExtensionsExecute(r ApiSystemExtensionsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PrismAPIService.SystemExtensions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/prism/system_extensions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.blueprintIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blueprint_ids", r.blueprintIds, "form", "")
	}
	if r.deviceFamilies != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "device_families", r.deviceFamilies, "form", "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", r.sortBy, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTransparencyDatabaseRequest struct {
	ctx context.Context
	ApiService *PrismAPIService
	blueprintIds *string
	deviceFamilies *string
	filter *string
	sortBy *string
	limit *string
	offset *string
}

// Filter results by one or more blueprint IDs separated by commas.
func (r ApiTransparencyDatabaseRequest) BlueprintIds(blueprintIds string) ApiTransparencyDatabaseRequest {
	r.blueprintIds = &blueprintIds
	return r
}

// Filter results by one or more device families separate by commas.
func (r ApiTransparencyDatabaseRequest) DeviceFamilies(deviceFamilies string) ApiTransparencyDatabaseRequest {
	r.deviceFamilies = &deviceFamilies
	return r
}

// JSON schema object containing one or more key value pairs. Note: For detailed information on fiters, see the Filters section at the begining of the Visibility API endpoints in this doc.
func (r ApiTransparencyDatabaseRequest) Filter(filter string) ApiTransparencyDatabaseRequest {
	r.filter = &filter
	return r
}

// Sort results by the name of a given response body key in either ascending (default behavior) or descending(&lt;code&gt;-&lt;/code&gt;) order.
func (r ApiTransparencyDatabaseRequest) SortBy(sortBy string) ApiTransparencyDatabaseRequest {
	r.sortBy = &sortBy
	return r
}

// A hard upper &lt;code&gt;limit&lt;/code&gt; is set at 300 device records returned per request. If more device records are expected, pagination should be used using the &lt;code&gt;limit&lt;/code&gt; and &lt;code&gt;offset&lt;/code&gt; parameters. Additionally, parameter queries can be added to a request to limit the results.
func (r ApiTransparencyDatabaseRequest) Limit(limit string) ApiTransparencyDatabaseRequest {
	r.limit = &limit
	return r
}

// Specify the starting record to return.
func (r ApiTransparencyDatabaseRequest) Offset(offset string) ApiTransparencyDatabaseRequest {
	r.offset = &offset
	return r
}

func (r ApiTransparencyDatabaseRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.TransparencyDatabaseExecute(r)
}

/*
TransparencyDatabase Transparency database

Get Transparency Database (TCC) attributes for macOS.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTransparencyDatabaseRequest
*/
func (a *PrismAPIService) TransparencyDatabase(ctx context.Context) ApiTransparencyDatabaseRequest {
	return ApiTransparencyDatabaseRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *PrismAPIService) TransparencyDatabaseExecute(r ApiTransparencyDatabaseRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PrismAPIService.TransparencyDatabase")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/prism/transparency_database"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.blueprintIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blueprint_ids", r.blueprintIds, "form", "")
	}
	if r.deviceFamilies != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "device_families", r.deviceFamilies, "form", "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", r.sortBy, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
