/*
Kandji API

<html><head></head><body><h1 id=&quot;welcome-to-the-kandji-api-documentation&quot;>Welcome to the Kandji API Documentation</h1> <p>You can find your API URL in Settings &gt; Access. The API URL will follow the below formats.</p> <ul> <li><p>US - <code>https://SubDomain.api.kandji.io</code></p> </li> <li><p>EU - <code>https://SubDomain.api.eu.kandji.io</code></p> </li> </ul> <p>For information on how to obtain an API token, please refer to the following support article.</p> <p><a href=&quot;https://support.kandji.io/api&quot;>https://support.kandji.io/api</a></p> <h4 id=&quot;rate-limit&quot;>Rate Limit</h4> <p>The Kandji API currently has an API rate limit of 10,000 requests per hour per customer.</p> <h4 id=&quot;request-methods&quot;>Request Methods</h4> <p>HTTP request methods supported by the Kandji API.</p> <div class=&quot;click-to-expand-wrapper is-table-wrapper&quot;><table> <thead> <tr> <th>Method</th> <th>Definition</th> </tr> </thead> <tbody> <tr> <td>GET</td> <td>The <code>GET</code> method requests a representation of the specified resource.</td> </tr> <tr> <td>POST</td> <td>The <code>POST</code> method submits an entity to the specified resource.</td> </tr> <tr> <td>PATCH</td> <td>The <code>PATCH</code> method applies partial modifications to a resource.</td> </tr> <tr> <td>DELETE</td> <td>The <code>DELETE</code> method deletes the specified resource.</td> </tr> </tbody> </table> </div><h4 id=&quot;response-codes&quot;>Response codes</h4> <p>Not all response codes apply to every endpoint.</p> <div class=&quot;click-to-expand-wrapper is-table-wrapper&quot;><table> <thead> <tr> <th>Code</th> <th>Response</th> </tr> </thead> <tbody> <tr> <td>200</td> <td>OK</td> </tr> <tr> <td>201</td> <td>Created</td> </tr> <tr> <td>204</td> <td>No content</td> </tr> <tr> <td></td> <td>Typical response when sending the DELETE method.</td> </tr> <tr> <td>400</td> <td>Bad Request</td> </tr> <tr> <td></td> <td>&quot;Command already running&quot; - The command may already be running in a <em>Pending</em> state waiting on the device.</td> </tr> <tr> <td></td> <td>&quot;Command is not allowed for current device&quot; - The command may not be compatible with the target device.</td> </tr> <tr> <td></td> <td>&quot;JSON parse error - Expecting ',' delimiter: line 3 column 2 (char 65)&quot;</td> </tr> <tr> <td>401</td> <td>Unauthorized</td> </tr> <tr> <td></td> <td>This error can occur if the token is incorrect, was revoked, or the token has expired.</td> </tr> <tr> <td>403</td> <td>Forbidden</td> </tr> <tr> <td></td> <td>The request was understood but cannot be authorized.</td> </tr> <tr> <td>404</td> <td>Not found</td> </tr> <tr> <td></td> <td>Unable to locate the resource in the Kandji tenant.</td> </tr> <tr> <td>415</td> <td>Unsupported Media Type</td> </tr> <tr> <td></td> <td>The request contains a media type which the server or resource does not support.</td> </tr> <tr> <td>500</td> <td>Internal server error</td> </tr> <tr> <td>503</td> <td>Service unavailable</td> </tr> <tr> <td></td> <td>This error can occur if a file upload is still being processed via the custom apps API.</td> </tr> </tbody> </table> </div><h4 id=&quot;data-structure&quot;>Data structure</h4> <p>The API returns all structured responses in JSON schema format.</p> <h4 id=&quot;examples&quot;>Examples</h4> <p>Code examples using the API can be found in the Kandji support <a href=&quot;https://github.com/kandji-inc/support/tree/main/api-tools&quot;>GitHub</a>.</p> </body></html>

API version: 1.0.0
Contact: mitchelsblake@gmail.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package kandji_sdk

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// PrismAPIService PrismAPI service
type PrismAPIService service

type ApiPrismActivationLockRequest struct {
	ctx context.Context
	ApiService *PrismAPIService
	blueprintIds *string
	deviceFamilies *string
	filter *string
	sortBy *string
	limit *string
	offset *string
}

// Filter results by one or more blueprint IDs separated by commas.
func (r ApiPrismActivationLockRequest) BlueprintIds(blueprintIds string) ApiPrismActivationLockRequest {
	r.blueprintIds = &blueprintIds
	return r
}

// Filter results by one or more device families separate by commas.
func (r ApiPrismActivationLockRequest) DeviceFamilies(deviceFamilies string) ApiPrismActivationLockRequest {
	r.deviceFamilies = &deviceFamilies
	return r
}

// JSON schema object containing one or more key value pairs. Note: For detailed information on fiters, see the Filters section at the begining of the Visibility API endpoints in this doc.
func (r ApiPrismActivationLockRequest) Filter(filter string) ApiPrismActivationLockRequest {
	r.filter = &filter
	return r
}

// Sort results by the name of a given response body key in either ascending (default behavior) or descending(&lt;code&gt;-&lt;/code&gt;) order.
func (r ApiPrismActivationLockRequest) SortBy(sortBy string) ApiPrismActivationLockRequest {
	r.sortBy = &sortBy
	return r
}

// A hard upper &lt;code&gt;limit&lt;/code&gt; is set at 300 device records returned per request. If more device records are expected, pagination should be used using the &lt;code&gt;limit&lt;/code&gt; and &lt;code&gt;offset&lt;/code&gt; parameters. Additionally, parameter queries can be added to a request to limit the results.
func (r ApiPrismActivationLockRequest) Limit(limit string) ApiPrismActivationLockRequest {
	r.limit = &limit
	return r
}

// Specify the starting record to return.
func (r ApiPrismActivationLockRequest) Offset(offset string) ApiPrismActivationLockRequest {
	r.offset = &offset
	return r
}

func (r ApiPrismActivationLockRequest) Execute() (*http.Response, error) {
	return r.ApiService.PrismActivationLockExecute(r)
}

/*
PrismActivationLock Activation lock

Get activation lock attributes for devices.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPrismActivationLockRequest
*/
func (a *PrismAPIService) PrismActivationLock(ctx context.Context) ApiPrismActivationLockRequest {
	return ApiPrismActivationLockRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *PrismAPIService) PrismActivationLockExecute(r ApiPrismActivationLockRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PrismAPIService.PrismActivationLock")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/prism/activation_lock"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.blueprintIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blueprint_ids", r.blueprintIds, "form", "")
	}
	if r.deviceFamilies != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "device_families", r.deviceFamilies, "form", "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", r.sortBy, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPrismApplicationFirewallRequest struct {
	ctx context.Context
	ApiService *PrismAPIService
	blueprintIds *string
	deviceFamilies *string
	filter *string
	sortBy *string
	limit *string
	offset *string
}

// Filter results by one or more blueprint IDs separated by commas.
func (r ApiPrismApplicationFirewallRequest) BlueprintIds(blueprintIds string) ApiPrismApplicationFirewallRequest {
	r.blueprintIds = &blueprintIds
	return r
}

// Filter results by one or more device families separate by commas.
func (r ApiPrismApplicationFirewallRequest) DeviceFamilies(deviceFamilies string) ApiPrismApplicationFirewallRequest {
	r.deviceFamilies = &deviceFamilies
	return r
}

// JSON schema object containing one or more key value pairs. Note: For detailed information on fiters, see the Filters section at the begining of the Visibility API endpoints in this doc.
func (r ApiPrismApplicationFirewallRequest) Filter(filter string) ApiPrismApplicationFirewallRequest {
	r.filter = &filter
	return r
}

// Sort results by the name of a given response body key in either ascending (default behavior) or descending(&lt;code&gt;-&lt;/code&gt;) order.
func (r ApiPrismApplicationFirewallRequest) SortBy(sortBy string) ApiPrismApplicationFirewallRequest {
	r.sortBy = &sortBy
	return r
}

// A hard upper &lt;code&gt;limit&lt;/code&gt; is set at 300 device records returned per request. If more device records are expected, pagination should be used using the &lt;code&gt;limit&lt;/code&gt; and &lt;code&gt;offset&lt;/code&gt; parameters. Additionally, parameter queries can be added to a request to limit the results.
func (r ApiPrismApplicationFirewallRequest) Limit(limit string) ApiPrismApplicationFirewallRequest {
	r.limit = &limit
	return r
}

// Specify the starting record to return.
func (r ApiPrismApplicationFirewallRequest) Offset(offset string) ApiPrismApplicationFirewallRequest {
	r.offset = &offset
	return r
}

func (r ApiPrismApplicationFirewallRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.PrismApplicationFirewallExecute(r)
}

/*
PrismApplicationFirewall Application firewall

Get Application Firewall details for macOS.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPrismApplicationFirewallRequest
*/
func (a *PrismAPIService) PrismApplicationFirewall(ctx context.Context) ApiPrismApplicationFirewallRequest {
	return ApiPrismApplicationFirewallRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *PrismAPIService) PrismApplicationFirewallExecute(r ApiPrismApplicationFirewallRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PrismAPIService.PrismApplicationFirewall")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/prism/application_firewall"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.blueprintIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blueprint_ids", r.blueprintIds, "form", "")
	}
	if r.deviceFamilies != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "device_families", r.deviceFamilies, "form", "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", r.sortBy, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPrismApplicationsRequest struct {
	ctx context.Context
	ApiService *PrismAPIService
	blueprintIds *string
	deviceFamilies *string
	filter *string
	sortBy *string
	limit *string
	offset *string
}

// Filter results by one or more blueprint IDs separated by commas.
func (r ApiPrismApplicationsRequest) BlueprintIds(blueprintIds string) ApiPrismApplicationsRequest {
	r.blueprintIds = &blueprintIds
	return r
}

// Filter results by one or more device families separate by commas.
func (r ApiPrismApplicationsRequest) DeviceFamilies(deviceFamilies string) ApiPrismApplicationsRequest {
	r.deviceFamilies = &deviceFamilies
	return r
}

// JSON schema object containing one or more key value pairs. Note: For detailed information on fiters, see the Filters section at the begining of the Visibility API endpoints in this doc.
func (r ApiPrismApplicationsRequest) Filter(filter string) ApiPrismApplicationsRequest {
	r.filter = &filter
	return r
}

// Sort results by the name of a given response body key in either ascending (default behavior) or descending(&lt;code&gt;-&lt;/code&gt;) order.
func (r ApiPrismApplicationsRequest) SortBy(sortBy string) ApiPrismApplicationsRequest {
	r.sortBy = &sortBy
	return r
}

// A hard upper &lt;code&gt;limit&lt;/code&gt; is set at 300 device records returned per request. If more device records are expected, pagination should be used using the &lt;code&gt;limit&lt;/code&gt; and &lt;code&gt;offset&lt;/code&gt; parameters. Additionally, parameter queries can be added to a request to limit the results.
func (r ApiPrismApplicationsRequest) Limit(limit string) ApiPrismApplicationsRequest {
	r.limit = &limit
	return r
}

// Specify the starting record to return.
func (r ApiPrismApplicationsRequest) Offset(offset string) ApiPrismApplicationsRequest {
	r.offset = &offset
	return r
}

func (r ApiPrismApplicationsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.PrismApplicationsExecute(r)
}

/*
PrismApplications Applications

Get the applications installed on macOS, iOS, iPadOS, and tvOS devices.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPrismApplicationsRequest
*/
func (a *PrismAPIService) PrismApplications(ctx context.Context) ApiPrismApplicationsRequest {
	return ApiPrismApplicationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *PrismAPIService) PrismApplicationsExecute(r ApiPrismApplicationsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PrismAPIService.PrismApplications")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/prism/apps"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.blueprintIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blueprint_ids", r.blueprintIds, "form", "")
	}
	if r.deviceFamilies != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "device_families", r.deviceFamilies, "form", "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", r.sortBy, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPrismCertificatesRequest struct {
	ctx context.Context
	ApiService *PrismAPIService
	blueprintIds *string
	deviceFamilies *string
	filter *string
	sortBy *string
	limit *string
	offset *string
}

// Filter results by one or more blueprint IDs separated by commas.
func (r ApiPrismCertificatesRequest) BlueprintIds(blueprintIds string) ApiPrismCertificatesRequest {
	r.blueprintIds = &blueprintIds
	return r
}

// Filter results by one or more device families separate by commas.
func (r ApiPrismCertificatesRequest) DeviceFamilies(deviceFamilies string) ApiPrismCertificatesRequest {
	r.deviceFamilies = &deviceFamilies
	return r
}

// JSON schema object containing one or more key value pairs. Note: For detailed information on fiters, see the Filters section at the begining of the Visibility API endpoints in this doc.
func (r ApiPrismCertificatesRequest) Filter(filter string) ApiPrismCertificatesRequest {
	r.filter = &filter
	return r
}

// Sort results by the name of a given response body key in either ascending (default behavior) or descending(&lt;code&gt;-&lt;/code&gt;) order.
func (r ApiPrismCertificatesRequest) SortBy(sortBy string) ApiPrismCertificatesRequest {
	r.sortBy = &sortBy
	return r
}

// A hard upper &lt;code&gt;limit&lt;/code&gt; is set at 300 device records returned per request. If more device records are expected, pagination should be used using the &lt;code&gt;limit&lt;/code&gt; and &lt;code&gt;offset&lt;/code&gt; parameters. Additionally, parameter queries can be added to a request to limit the results.
func (r ApiPrismCertificatesRequest) Limit(limit string) ApiPrismCertificatesRequest {
	r.limit = &limit
	return r
}

// Specify the starting record to return.
func (r ApiPrismCertificatesRequest) Offset(offset string) ApiPrismCertificatesRequest {
	r.offset = &offset
	return r
}

func (r ApiPrismCertificatesRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.PrismCertificatesExecute(r)
}

/*
PrismCertificates Certificates

Get certificate details.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPrismCertificatesRequest
*/
func (a *PrismAPIService) PrismCertificates(ctx context.Context) ApiPrismCertificatesRequest {
	return ApiPrismCertificatesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *PrismAPIService) PrismCertificatesExecute(r ApiPrismCertificatesRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PrismAPIService.PrismCertificates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/prism/certificates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.blueprintIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blueprint_ids", r.blueprintIds, "form", "")
	}
	if r.deviceFamilies != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "device_families", r.deviceFamilies, "form", "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", r.sortBy, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPrismCountRequest struct {
	ctx context.Context
	ApiService *PrismAPIService
	category *string
}

// &lt;p&gt;Return the count of records for the specified category.  If a category contains spaces substitute the spaces for underscores (&amp;quot;_&amp;quot;) when using the API query.&lt;/p&gt; &lt;p&gt;Examples: apps device_information kernel_extensions system_extensions&lt;/p&gt;
func (r ApiPrismCountRequest) Category(category string) ApiPrismCountRequest {
	r.category = &category
	return r
}

func (r ApiPrismCountRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.PrismCountExecute(r)
}

/*
PrismCount Count

<p>Get the total record count for the specified Prism category.</p>
<p>If a category contains spaces substitute the spaces for underscores (&quot;_&quot;) when using the API query.</p>
<p>Example: <code>Device information</code> becomes <code>device_information</code>.</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPrismCountRequest
*/
func (a *PrismAPIService) PrismCount(ctx context.Context) ApiPrismCountRequest {
	return ApiPrismCountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *PrismAPIService) PrismCountExecute(r ApiPrismCountRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PrismAPIService.PrismCount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/prism/count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.category == nil {
		return localVarReturnValue, nil, reportError("category is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "category", r.category, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPrismDesktopAndScreensaverRequest struct {
	ctx context.Context
	ApiService *PrismAPIService
	blueprintIds *string
	deviceFamilies *string
	filter *string
	sortBy *string
	limit *string
	offset *string
}

// Filter results by one or more blueprint IDs separated by commas.
func (r ApiPrismDesktopAndScreensaverRequest) BlueprintIds(blueprintIds string) ApiPrismDesktopAndScreensaverRequest {
	r.blueprintIds = &blueprintIds
	return r
}

// Filter results by one or more device families separate by commas.
func (r ApiPrismDesktopAndScreensaverRequest) DeviceFamilies(deviceFamilies string) ApiPrismDesktopAndScreensaverRequest {
	r.deviceFamilies = &deviceFamilies
	return r
}

// JSON schema object containing one or more key value pairs. Note: For detailed information on fiters, see the Filters section at the begining of the Visibility API endpoints in this doc.
func (r ApiPrismDesktopAndScreensaverRequest) Filter(filter string) ApiPrismDesktopAndScreensaverRequest {
	r.filter = &filter
	return r
}

// Sort results by the name of a given response body key in either ascending (default behavior) or descending(&lt;code&gt;-&lt;/code&gt;) order.
func (r ApiPrismDesktopAndScreensaverRequest) SortBy(sortBy string) ApiPrismDesktopAndScreensaverRequest {
	r.sortBy = &sortBy
	return r
}

// A hard upper &lt;code&gt;limit&lt;/code&gt; is set at 300 device records returned per request. If more device records are expected, pagination should be used using the &lt;code&gt;limit&lt;/code&gt; and &lt;code&gt;offset&lt;/code&gt; parameters. Additionally, parameter queries can be added to a request to limit the results.
func (r ApiPrismDesktopAndScreensaverRequest) Limit(limit string) ApiPrismDesktopAndScreensaverRequest {
	r.limit = &limit
	return r
}

// Specify the starting record to return.
func (r ApiPrismDesktopAndScreensaverRequest) Offset(offset string) ApiPrismDesktopAndScreensaverRequest {
	r.offset = &offset
	return r
}

func (r ApiPrismDesktopAndScreensaverRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.PrismDesktopAndScreensaverExecute(r)
}

/*
PrismDesktopAndScreensaver Desktop and Screensaver

Get Desktop and Screensaver details for macOS.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPrismDesktopAndScreensaverRequest
*/
func (a *PrismAPIService) PrismDesktopAndScreensaver(ctx context.Context) ApiPrismDesktopAndScreensaverRequest {
	return ApiPrismDesktopAndScreensaverRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *PrismAPIService) PrismDesktopAndScreensaverExecute(r ApiPrismDesktopAndScreensaverRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PrismAPIService.PrismDesktopAndScreensaver")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/prism/desktop_and_screensaver"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.blueprintIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blueprint_ids", r.blueprintIds, "form", "")
	}
	if r.deviceFamilies != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "device_families", r.deviceFamilies, "form", "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", r.sortBy, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPrismDeviceInformationRequest struct {
	ctx context.Context
	ApiService *PrismAPIService
	blueprintIds *string
	deviceFamilies *string
	filter *string
	sortBy *string
	limit *string
	offset *string
	body *string
}

// Filter results by one or more blueprint IDs separated by commas.
func (r ApiPrismDeviceInformationRequest) BlueprintIds(blueprintIds string) ApiPrismDeviceInformationRequest {
	r.blueprintIds = &blueprintIds
	return r
}

// Filter results by one or more device families separate by commas.
func (r ApiPrismDeviceInformationRequest) DeviceFamilies(deviceFamilies string) ApiPrismDeviceInformationRequest {
	r.deviceFamilies = &deviceFamilies
	return r
}

// &lt;p&gt;JSON schema object containing one or more key value pairs.&lt;/p&gt; &lt;p&gt;Note: For detailed information on fiters, see the Filters section at the begining of the Visibility API endpoints in this doc.&lt;/p&gt;
func (r ApiPrismDeviceInformationRequest) Filter(filter string) ApiPrismDeviceInformationRequest {
	r.filter = &filter
	return r
}

// Sort results by the name of a given response body key in either ascending (default behavior) or descending(&lt;code&gt;-&lt;/code&gt;) order.
func (r ApiPrismDeviceInformationRequest) SortBy(sortBy string) ApiPrismDeviceInformationRequest {
	r.sortBy = &sortBy
	return r
}

// A hard upper &lt;code&gt;limit&lt;/code&gt; is set at 300 device records returned per request. If more device records are expected, pagination should be used using the &lt;code&gt;limit&lt;/code&gt; and &lt;code&gt;offset&lt;/code&gt; parameters. Additionally, parameter queries can be added to a request to limit the results.
func (r ApiPrismDeviceInformationRequest) Limit(limit string) ApiPrismDeviceInformationRequest {
	r.limit = &limit
	return r
}

// Specify the starting record to return
func (r ApiPrismDeviceInformationRequest) Offset(offset string) ApiPrismDeviceInformationRequest {
	r.offset = &offset
	return r
}

func (r ApiPrismDeviceInformationRequest) Body(body string) ApiPrismDeviceInformationRequest {
	r.body = &body
	return r
}

func (r ApiPrismDeviceInformationRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.PrismDeviceInformationExecute(r)
}

/*
PrismDeviceInformation Device information

Get attributes about devices.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPrismDeviceInformationRequest
*/
func (a *PrismAPIService) PrismDeviceInformation(ctx context.Context) ApiPrismDeviceInformationRequest {
	return ApiPrismDeviceInformationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *PrismAPIService) PrismDeviceInformationExecute(r ApiPrismDeviceInformationRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PrismAPIService.PrismDeviceInformation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/prism/device_information"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.blueprintIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blueprint_ids", r.blueprintIds, "form", "")
	}
	if r.deviceFamilies != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "device_families", r.deviceFamilies, "form", "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", r.sortBy, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPrismFilevaultRequest struct {
	ctx context.Context
	ApiService *PrismAPIService
	blueprintIds *string
	deviceFamilies *string
	filter *string
	sortBy *string
	limit *string
	offset *string
}

// Filter results by one or more blueprint IDs separated by commas.
func (r ApiPrismFilevaultRequest) BlueprintIds(blueprintIds string) ApiPrismFilevaultRequest {
	r.blueprintIds = &blueprintIds
	return r
}

// Filter results by one or more device families separate by commas.
func (r ApiPrismFilevaultRequest) DeviceFamilies(deviceFamilies string) ApiPrismFilevaultRequest {
	r.deviceFamilies = &deviceFamilies
	return r
}

// JSON schema object containing one or more key value pairs. Note: For detailed information on fiters, see the Filters section at the begining of the Visibility API endpoints in this doc.
func (r ApiPrismFilevaultRequest) Filter(filter string) ApiPrismFilevaultRequest {
	r.filter = &filter
	return r
}

// Sort results by the name of a given response body key in either ascending (default behavior) or descending(&lt;code&gt;-&lt;/code&gt;) order.
func (r ApiPrismFilevaultRequest) SortBy(sortBy string) ApiPrismFilevaultRequest {
	r.sortBy = &sortBy
	return r
}

// A hard upper &lt;code&gt;limit&lt;/code&gt; is set at 300 device records returned per request. If more device records are expected, pagination should be used using the &lt;code&gt;limit&lt;/code&gt; and &lt;code&gt;offset&lt;/code&gt; parameters. Additionally, parameter queries can be added to a request to limit the results.
func (r ApiPrismFilevaultRequest) Limit(limit string) ApiPrismFilevaultRequest {
	r.limit = &limit
	return r
}

// Specify the starting record to return
func (r ApiPrismFilevaultRequest) Offset(offset string) ApiPrismFilevaultRequest {
	r.offset = &offset
	return r
}

func (r ApiPrismFilevaultRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.PrismFilevaultExecute(r)
}

/*
PrismFilevault FileVault

Get FileVault information for macOS.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPrismFilevaultRequest
*/
func (a *PrismAPIService) PrismFilevault(ctx context.Context) ApiPrismFilevaultRequest {
	return ApiPrismFilevaultRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *PrismAPIService) PrismFilevaultExecute(r ApiPrismFilevaultRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PrismAPIService.PrismFilevault")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/prism/filevault"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.blueprintIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blueprint_ids", r.blueprintIds, "form", "")
	}
	if r.deviceFamilies != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "device_families", r.deviceFamilies, "form", "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", r.sortBy, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPrismGatekeeperAndXprotectRequest struct {
	ctx context.Context
	ApiService *PrismAPIService
	blueprintIds *string
	deviceFamilies *string
	filter *string
	sortBy *string
	limit *string
	offset *string
}

// Filter results by one or more blueprint IDs separated by commas.
func (r ApiPrismGatekeeperAndXprotectRequest) BlueprintIds(blueprintIds string) ApiPrismGatekeeperAndXprotectRequest {
	r.blueprintIds = &blueprintIds
	return r
}

// Results are limited to Mac only as Gatekeeper and XProtect are not applicable for other platfroms.
func (r ApiPrismGatekeeperAndXprotectRequest) DeviceFamilies(deviceFamilies string) ApiPrismGatekeeperAndXprotectRequest {
	r.deviceFamilies = &deviceFamilies
	return r
}

// JSON schema object containing one or more key value pairs. Note: For detailed information on fiters, see the Filters section at the begining of the Visibility API endpoints in this doc.
func (r ApiPrismGatekeeperAndXprotectRequest) Filter(filter string) ApiPrismGatekeeperAndXprotectRequest {
	r.filter = &filter
	return r
}

// Sort results by the name of a given response body key in either ascending (default behavior) or descending(&lt;code&gt;-&lt;/code&gt;) order.
func (r ApiPrismGatekeeperAndXprotectRequest) SortBy(sortBy string) ApiPrismGatekeeperAndXprotectRequest {
	r.sortBy = &sortBy
	return r
}

// A hard upper &lt;code&gt;limit&lt;/code&gt; is set at 300 device records returned per request. If more device records are expected, pagination should be used using the &lt;code&gt;limit&lt;/code&gt; and &lt;code&gt;offset&lt;/code&gt; parameters. Additionally, parameter queries can be added to a request to limit the results.
func (r ApiPrismGatekeeperAndXprotectRequest) Limit(limit string) ApiPrismGatekeeperAndXprotectRequest {
	r.limit = &limit
	return r
}

// Specify the starting record to return
func (r ApiPrismGatekeeperAndXprotectRequest) Offset(offset string) ApiPrismGatekeeperAndXprotectRequest {
	r.offset = &offset
	return r
}

func (r ApiPrismGatekeeperAndXprotectRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.PrismGatekeeperAndXprotectExecute(r)
}

/*
PrismGatekeeperAndXprotect Gatekeeper and XProtect

Get Gatekeeper and XProtect attributes for macOS.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPrismGatekeeperAndXprotectRequest
*/
func (a *PrismAPIService) PrismGatekeeperAndXprotect(ctx context.Context) ApiPrismGatekeeperAndXprotectRequest {
	return ApiPrismGatekeeperAndXprotectRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *PrismAPIService) PrismGatekeeperAndXprotectExecute(r ApiPrismGatekeeperAndXprotectRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PrismAPIService.PrismGatekeeperAndXprotect")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/prism/gatekeeper_and_xprotect"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.blueprintIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blueprint_ids", r.blueprintIds, "form", "")
	}
	if r.deviceFamilies != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "device_families", r.deviceFamilies, "form", "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", r.sortBy, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPrismGetCategoryExportRequest struct {
	ctx context.Context
	ApiService *PrismAPIService
	exportId string
}

func (r ApiPrismGetCategoryExportRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.PrismGetCategoryExportExecute(r)
}

/*
PrismGetCategoryExport Get category export

<p>Get an export request's status. To download the export, use the <code>signed_url</code>. This will download a CSV file containing the exported category information.</p>
<h3 id=&quot;request-parameters&quot;>Request Parameters</h3>
<p>export_id (path parameter): The unique identifier of the the export job.</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param exportId
 @return ApiPrismGetCategoryExportRequest
*/
func (a *PrismAPIService) PrismGetCategoryExport(ctx context.Context, exportId string) ApiPrismGetCategoryExportRequest {
	return ApiPrismGetCategoryExportRequest{
		ApiService: a,
		ctx: ctx,
		exportId: exportId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *PrismAPIService) PrismGetCategoryExportExecute(r ApiPrismGetCategoryExportRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PrismAPIService.PrismGetCategoryExport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/prism/export/{export_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"export_id"+"}", url.PathEscape(parameterValueToString(r.exportId, "exportId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPrismInstalledProfilesRequest struct {
	ctx context.Context
	ApiService *PrismAPIService
	blueprintIds *string
	deviceFamilies *string
	filter *string
	sortBy *string
	limit *string
	offset *string
}

// Filter results by one or more blueprint IDs separated by commas.
func (r ApiPrismInstalledProfilesRequest) BlueprintIds(blueprintIds string) ApiPrismInstalledProfilesRequest {
	r.blueprintIds = &blueprintIds
	return r
}

// Filter results by one or more device families separate by commas.
func (r ApiPrismInstalledProfilesRequest) DeviceFamilies(deviceFamilies string) ApiPrismInstalledProfilesRequest {
	r.deviceFamilies = &deviceFamilies
	return r
}

// JSON schema object containing one or more key value pairs. Note: For detailed information on fiters, see the Filters section at the begining of the Visibility API endpoints in this doc.
func (r ApiPrismInstalledProfilesRequest) Filter(filter string) ApiPrismInstalledProfilesRequest {
	r.filter = &filter
	return r
}

// Sort results by the name of a given response body key in either ascending (default behavior) or descending(&lt;code&gt;-&lt;/code&gt;) order.
func (r ApiPrismInstalledProfilesRequest) SortBy(sortBy string) ApiPrismInstalledProfilesRequest {
	r.sortBy = &sortBy
	return r
}

// A hard upper &lt;code&gt;limit&lt;/code&gt; is set at 300 device records returned per request. If more device records are expected, pagination should be used using the &lt;code&gt;limit&lt;/code&gt; and &lt;code&gt;offset&lt;/code&gt; parameters. Additionally, parameter queries can be added to a request to limit the results.
func (r ApiPrismInstalledProfilesRequest) Limit(limit string) ApiPrismInstalledProfilesRequest {
	r.limit = &limit
	return r
}

// Specify the starting record to return.
func (r ApiPrismInstalledProfilesRequest) Offset(offset string) ApiPrismInstalledProfilesRequest {
	r.offset = &offset
	return r
}

func (r ApiPrismInstalledProfilesRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.PrismInstalledProfilesExecute(r)
}

/*
PrismInstalledProfiles Installed profiles

Get Installed Profiles attributes for macOS, iOS, iPadOS, and tvOS.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPrismInstalledProfilesRequest
*/
func (a *PrismAPIService) PrismInstalledProfiles(ctx context.Context) ApiPrismInstalledProfilesRequest {
	return ApiPrismInstalledProfilesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *PrismAPIService) PrismInstalledProfilesExecute(r ApiPrismInstalledProfilesRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PrismAPIService.PrismInstalledProfiles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/prism/installed_profiles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.blueprintIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blueprint_ids", r.blueprintIds, "form", "")
	}
	if r.deviceFamilies != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "device_families", r.deviceFamilies, "form", "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", r.sortBy, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPrismKernelExtensionsRequest struct {
	ctx context.Context
	ApiService *PrismAPIService
	blueprintIds *string
	deviceFamilies *string
	filter *string
	sortBy *string
	limit *string
	offset *string
}

// Filter results by one or more blueprint IDs separated by commas.
func (r ApiPrismKernelExtensionsRequest) BlueprintIds(blueprintIds string) ApiPrismKernelExtensionsRequest {
	r.blueprintIds = &blueprintIds
	return r
}

// Filter results by one or more device families separate by commas.
func (r ApiPrismKernelExtensionsRequest) DeviceFamilies(deviceFamilies string) ApiPrismKernelExtensionsRequest {
	r.deviceFamilies = &deviceFamilies
	return r
}

// SON schema object containing one or more key value pairs. Note: For detailed information on fiters, see the Filters section at the begining of the Visibility API endpoints in this doc.
func (r ApiPrismKernelExtensionsRequest) Filter(filter string) ApiPrismKernelExtensionsRequest {
	r.filter = &filter
	return r
}

// Sort results by the name of a given response body key in either ascending (default behavior) or descending(&lt;code&gt;-&lt;/code&gt;) order.
func (r ApiPrismKernelExtensionsRequest) SortBy(sortBy string) ApiPrismKernelExtensionsRequest {
	r.sortBy = &sortBy
	return r
}

// A hard upper &lt;code&gt;limit&lt;/code&gt; is set at 300 device records returned per request. If more device records are expected, pagination should be used using the &lt;code&gt;limit&lt;/code&gt; and &lt;code&gt;offset&lt;/code&gt; parameters. Additionally, parameter queries can be added to a request to limit the results.
func (r ApiPrismKernelExtensionsRequest) Limit(limit string) ApiPrismKernelExtensionsRequest {
	r.limit = &limit
	return r
}

// Specify the starting record to return.
func (r ApiPrismKernelExtensionsRequest) Offset(offset string) ApiPrismKernelExtensionsRequest {
	r.offset = &offset
	return r
}

func (r ApiPrismKernelExtensionsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.PrismKernelExtensionsExecute(r)
}

/*
PrismKernelExtensions Kernel Extensions

Get Kernel Extension attributes for macOS.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPrismKernelExtensionsRequest
*/
func (a *PrismAPIService) PrismKernelExtensions(ctx context.Context) ApiPrismKernelExtensionsRequest {
	return ApiPrismKernelExtensionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *PrismAPIService) PrismKernelExtensionsExecute(r ApiPrismKernelExtensionsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PrismAPIService.PrismKernelExtensions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/prism/kernel_extensions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.blueprintIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blueprint_ids", r.blueprintIds, "form", "")
	}
	if r.deviceFamilies != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "device_families", r.deviceFamilies, "form", "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", r.sortBy, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPrismLaunchAgentsAndDaemonsRequest struct {
	ctx context.Context
	ApiService *PrismAPIService
	blueprintIds *string
	deviceFamilies *string
	filter *string
	sortBy *string
	limit *string
	offset *string
}

// Filter results by one or more blueprint IDs separated by commas.
func (r ApiPrismLaunchAgentsAndDaemonsRequest) BlueprintIds(blueprintIds string) ApiPrismLaunchAgentsAndDaemonsRequest {
	r.blueprintIds = &blueprintIds
	return r
}

// Filter results by one or more device families separate by commas.
func (r ApiPrismLaunchAgentsAndDaemonsRequest) DeviceFamilies(deviceFamilies string) ApiPrismLaunchAgentsAndDaemonsRequest {
	r.deviceFamilies = &deviceFamilies
	return r
}

// JSON schema object containing one or more key value pairs. Note: For detailed information on fiters, see the Filters section at the begining of the Visibility API endpoints in this doc.
func (r ApiPrismLaunchAgentsAndDaemonsRequest) Filter(filter string) ApiPrismLaunchAgentsAndDaemonsRequest {
	r.filter = &filter
	return r
}

// Sort results by the name of a given response body key in either ascending (default behavior) or descending(&lt;code&gt;-&lt;/code&gt;) order.
func (r ApiPrismLaunchAgentsAndDaemonsRequest) SortBy(sortBy string) ApiPrismLaunchAgentsAndDaemonsRequest {
	r.sortBy = &sortBy
	return r
}

// A hard upper &lt;code&gt;limit&lt;/code&gt; is set at 300 device records returned per request. If more device records are expected, pagination should be used using the &lt;code&gt;limit&lt;/code&gt; and &lt;code&gt;offset&lt;/code&gt; parameters. Additionally, parameter queries can be added to a request to limit the results.
func (r ApiPrismLaunchAgentsAndDaemonsRequest) Limit(limit string) ApiPrismLaunchAgentsAndDaemonsRequest {
	r.limit = &limit
	return r
}

// Specify the starting record to return.
func (r ApiPrismLaunchAgentsAndDaemonsRequest) Offset(offset string) ApiPrismLaunchAgentsAndDaemonsRequest {
	r.offset = &offset
	return r
}

func (r ApiPrismLaunchAgentsAndDaemonsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.PrismLaunchAgentsAndDaemonsExecute(r)
}

/*
PrismLaunchAgentsAndDaemons Launch Agents and Daemons

Get Launch Agents and Daemons installed on macOS.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPrismLaunchAgentsAndDaemonsRequest
*/
func (a *PrismAPIService) PrismLaunchAgentsAndDaemons(ctx context.Context) ApiPrismLaunchAgentsAndDaemonsRequest {
	return ApiPrismLaunchAgentsAndDaemonsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *PrismAPIService) PrismLaunchAgentsAndDaemonsExecute(r ApiPrismLaunchAgentsAndDaemonsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PrismAPIService.PrismLaunchAgentsAndDaemons")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/prism/launch_agents_and_daemons"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.blueprintIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blueprint_ids", r.blueprintIds, "form", "")
	}
	if r.deviceFamilies != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "device_families", r.deviceFamilies, "form", "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", r.sortBy, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPrismLocalUsersRequest struct {
	ctx context.Context
	ApiService *PrismAPIService
	blueprintIds *string
	deviceFamilies *string
	filter *string
	sortBy *string
	limit *string
	offset *string
}

// Filter results by one or more blueprint IDs separated by commas.
func (r ApiPrismLocalUsersRequest) BlueprintIds(blueprintIds string) ApiPrismLocalUsersRequest {
	r.blueprintIds = &blueprintIds
	return r
}

// Filter results by one or more device families separate by commas.
func (r ApiPrismLocalUsersRequest) DeviceFamilies(deviceFamilies string) ApiPrismLocalUsersRequest {
	r.deviceFamilies = &deviceFamilies
	return r
}

// JSON schema object containing one or more key value pairs. Note: For detailed information on fiters, see the Filters section at the begining of the Visibility API endpoints in this doc.
func (r ApiPrismLocalUsersRequest) Filter(filter string) ApiPrismLocalUsersRequest {
	r.filter = &filter
	return r
}

// Sort results by the name of a given response body key in either ascending (default behavior) or descending(&lt;code&gt;-&lt;/code&gt;) order.
func (r ApiPrismLocalUsersRequest) SortBy(sortBy string) ApiPrismLocalUsersRequest {
	r.sortBy = &sortBy
	return r
}

// A hard upper &lt;code&gt;limit&lt;/code&gt; is set at 300 device records returned per request. If more device records are expected, pagination should be used using the &lt;code&gt;limit&lt;/code&gt; and &lt;code&gt;offset&lt;/code&gt; parameters. Additionally, parameter queries can be added to a request to limit the results.
func (r ApiPrismLocalUsersRequest) Limit(limit string) ApiPrismLocalUsersRequest {
	r.limit = &limit
	return r
}

// Specify the starting record to return.
func (r ApiPrismLocalUsersRequest) Offset(offset string) ApiPrismLocalUsersRequest {
	r.offset = &offset
	return r
}

func (r ApiPrismLocalUsersRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.PrismLocalUsersExecute(r)
}

/*
PrismLocalUsers Local users

Get Local Users detials for macOS.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPrismLocalUsersRequest
*/
func (a *PrismAPIService) PrismLocalUsers(ctx context.Context) ApiPrismLocalUsersRequest {
	return ApiPrismLocalUsersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *PrismAPIService) PrismLocalUsersExecute(r ApiPrismLocalUsersRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PrismAPIService.PrismLocalUsers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/prism/local_users"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.blueprintIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blueprint_ids", r.blueprintIds, "form", "")
	}
	if r.deviceFamilies != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "device_families", r.deviceFamilies, "form", "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", r.sortBy, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPrismRequestCategoryExportRequest struct {
	ctx context.Context
	ApiService *PrismAPIService
	body *string
}

func (r ApiPrismRequestCategoryExportRequest) Body(body string) ApiPrismRequestCategoryExportRequest {
	r.body = &body
	return r
}

func (r ApiPrismRequestCategoryExportRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.PrismRequestCategoryExportExecute(r)
}

/*
PrismRequestCategoryExport Request category export

<p>Request export of a category. The <code>id</code> key is used when checking the export status using the <em>Request category export</em> endpoint.</p>
<p><strong>Request Body Parameters: application/json</strong></p>
<div class=&quot;click-to-expand-wrapper is-table-wrapper&quot;><table>
<thead>
<tr>
<th>Key</th>
<th>Type</th>
<th>Possible value(s)</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>blueprint_ids</code></td>
<td><code>array</code></td>
<td><code>[&quot;string&quot;, &quot;string&quot;, &quot;string&quot;]</code></td>
<td>List of one or more comma separate blueprint IDs.</td>
</tr>
<tr>
<td><code>category</code></td>
<td><code>string</code></td>
<td><code>apps</code> ,  <br /><code>activation_lock</code> ,  <br /><code>desktop_and_screensaver</code> ,  <br /><code>device_information</code> ,  <br /><code>gatekeeper_and_xprotect</code> ,  <br /><code>installed_profiles</code> ,  <br /><code>kernel_extensions</code> ,  <br /><code>local_users</code> ,  <br /><code>launch_agents_and_daemons</code> ,  <br /><code>system_extensions</code> ,  <br /><code>startup_settings</code> ,  <br /><code>transparency_database</code></td>
<td>Only one category per export reqest.</td>
</tr>
<tr>
<td><code>device_families</code></td>
<td><code>array</code></td>
<td><code>[&quot;Mac&quot;, &quot;iPhone&quot;, &quot;iPad&quot;, &quot;tvOS&quot;]</code></td>
<td>List of one or more comma separted string values for device families.</td>
</tr>
<tr>
<td><code>filter</code></td>
<td><code>object</code></td>
<td><code>{&quot;apple_silicon&quot;: {&quot;eq&quot;: true}, &quot;device__name&quot;: {&quot;like&quot;: [&quot;this&quot;, &quot;or_this&quot;]}}</code></td>
<td>JSON schema object containing one or more key value pairs.  <br />  <br /><strong>Note</strong>: For detailed information on fiters, see the Filters section at the begining of the Visibility API endpoints in this doc.</td>
</tr>
<tr>
<td><code>sort_by</code></td>
<td><code>string</code></td>
<td></td>
<td>Sort results by the name of a given response body key in either ascending (default behavior) or descending(`-`) order.</td>
</tr>
</tbody>
</table>
</div>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPrismRequestCategoryExportRequest
*/
func (a *PrismAPIService) PrismRequestCategoryExport(ctx context.Context) ApiPrismRequestCategoryExportRequest {
	return ApiPrismRequestCategoryExportRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *PrismAPIService) PrismRequestCategoryExportExecute(r ApiPrismRequestCategoryExportRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PrismAPIService.PrismRequestCategoryExport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/prism/export"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPrismStartupSettingsRequest struct {
	ctx context.Context
	ApiService *PrismAPIService
	blueprintIds *string
	deviceFamilies *string
	filter *string
	sortBy *string
	limit *string
	offset *string
}

// Filter results by one or more blueprint IDs separated by commas.
func (r ApiPrismStartupSettingsRequest) BlueprintIds(blueprintIds string) ApiPrismStartupSettingsRequest {
	r.blueprintIds = &blueprintIds
	return r
}

// Filter results by one or more device families separate by commas.
func (r ApiPrismStartupSettingsRequest) DeviceFamilies(deviceFamilies string) ApiPrismStartupSettingsRequest {
	r.deviceFamilies = &deviceFamilies
	return r
}

// JSON schema object containing one or more key value pairs. Note: For detailed information on fiters, see the Filters section at the begining of the Visibility API endpoints in this doc.
func (r ApiPrismStartupSettingsRequest) Filter(filter string) ApiPrismStartupSettingsRequest {
	r.filter = &filter
	return r
}

// Sort results by the name of a given response body key in either ascending (default behavior) or descending(&lt;code&gt;-&lt;/code&gt;) order.
func (r ApiPrismStartupSettingsRequest) SortBy(sortBy string) ApiPrismStartupSettingsRequest {
	r.sortBy = &sortBy
	return r
}

// A hard upper &lt;code&gt;limit&lt;/code&gt; is set at 300 device records returned per request. If more device records are expected, pagination should be used using the &lt;code&gt;limit&lt;/code&gt; and &lt;code&gt;offset&lt;/code&gt; parameters. Additionally, parameter queries can be added to a request to limit the results.
func (r ApiPrismStartupSettingsRequest) Limit(limit string) ApiPrismStartupSettingsRequest {
	r.limit = &limit
	return r
}

// Specify the starting record to return
func (r ApiPrismStartupSettingsRequest) Offset(offset string) ApiPrismStartupSettingsRequest {
	r.offset = &offset
	return r
}

func (r ApiPrismStartupSettingsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.PrismStartupSettingsExecute(r)
}

/*
PrismStartupSettings Startup settings

Get Startup settings for macOS.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPrismStartupSettingsRequest
*/
func (a *PrismAPIService) PrismStartupSettings(ctx context.Context) ApiPrismStartupSettingsRequest {
	return ApiPrismStartupSettingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *PrismAPIService) PrismStartupSettingsExecute(r ApiPrismStartupSettingsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PrismAPIService.PrismStartupSettings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/prism/startup_settings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.blueprintIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blueprint_ids", r.blueprintIds, "form", "")
	}
	if r.deviceFamilies != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "device_families", r.deviceFamilies, "form", "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", r.sortBy, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPrismSystemExtensionsRequest struct {
	ctx context.Context
	ApiService *PrismAPIService
	blueprintIds *string
	deviceFamilies *string
	filter *string
	sortBy *string
	limit *string
	offset *string
}

// Filter results by one or more blueprint IDs separated by commas.
func (r ApiPrismSystemExtensionsRequest) BlueprintIds(blueprintIds string) ApiPrismSystemExtensionsRequest {
	r.blueprintIds = &blueprintIds
	return r
}

// Filter results by one or more device families separate by commas.
func (r ApiPrismSystemExtensionsRequest) DeviceFamilies(deviceFamilies string) ApiPrismSystemExtensionsRequest {
	r.deviceFamilies = &deviceFamilies
	return r
}

// JSON schema object containing one or more key value pairs. Note: For detailed information on fiters, see the Filters section at the begining of the Visibility API endpoints in this doc.
func (r ApiPrismSystemExtensionsRequest) Filter(filter string) ApiPrismSystemExtensionsRequest {
	r.filter = &filter
	return r
}

// Sort results by the name of a given response body key in either ascending (default behavior) or descending(&lt;code&gt;-&lt;/code&gt;) order.
func (r ApiPrismSystemExtensionsRequest) SortBy(sortBy string) ApiPrismSystemExtensionsRequest {
	r.sortBy = &sortBy
	return r
}

// A hard upper &lt;code&gt;limit&lt;/code&gt; is set at 300 device records returned per request. If more device records are expected, pagination should be used using the &lt;code&gt;limit&lt;/code&gt; and &lt;code&gt;offset&lt;/code&gt; parameters. Additionally, parameter queries can be added to a request to limit the results.
func (r ApiPrismSystemExtensionsRequest) Limit(limit string) ApiPrismSystemExtensionsRequest {
	r.limit = &limit
	return r
}

// Specify the starting record to return.
func (r ApiPrismSystemExtensionsRequest) Offset(offset string) ApiPrismSystemExtensionsRequest {
	r.offset = &offset
	return r
}

func (r ApiPrismSystemExtensionsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.PrismSystemExtensionsExecute(r)
}

/*
PrismSystemExtensions System Extensions

Get System Extension attributes for macOS.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPrismSystemExtensionsRequest
*/
func (a *PrismAPIService) PrismSystemExtensions(ctx context.Context) ApiPrismSystemExtensionsRequest {
	return ApiPrismSystemExtensionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *PrismAPIService) PrismSystemExtensionsExecute(r ApiPrismSystemExtensionsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PrismAPIService.PrismSystemExtensions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/prism/system_extensions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.blueprintIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blueprint_ids", r.blueprintIds, "form", "")
	}
	if r.deviceFamilies != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "device_families", r.deviceFamilies, "form", "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", r.sortBy, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPrismTransparencyDatabaseRequest struct {
	ctx context.Context
	ApiService *PrismAPIService
	blueprintIds *string
	deviceFamilies *string
	filter *string
	sortBy *string
	limit *string
	offset *string
}

// Filter results by one or more blueprint IDs separated by commas.
func (r ApiPrismTransparencyDatabaseRequest) BlueprintIds(blueprintIds string) ApiPrismTransparencyDatabaseRequest {
	r.blueprintIds = &blueprintIds
	return r
}

// Filter results by one or more device families separate by commas.
func (r ApiPrismTransparencyDatabaseRequest) DeviceFamilies(deviceFamilies string) ApiPrismTransparencyDatabaseRequest {
	r.deviceFamilies = &deviceFamilies
	return r
}

// JSON schema object containing one or more key value pairs. Note: For detailed information on fiters, see the Filters section at the begining of the Visibility API endpoints in this doc.
func (r ApiPrismTransparencyDatabaseRequest) Filter(filter string) ApiPrismTransparencyDatabaseRequest {
	r.filter = &filter
	return r
}

// Sort results by the name of a given response body key in either ascending (default behavior) or descending(&lt;code&gt;-&lt;/code&gt;) order.
func (r ApiPrismTransparencyDatabaseRequest) SortBy(sortBy string) ApiPrismTransparencyDatabaseRequest {
	r.sortBy = &sortBy
	return r
}

// A hard upper &lt;code&gt;limit&lt;/code&gt; is set at 300 device records returned per request. If more device records are expected, pagination should be used using the &lt;code&gt;limit&lt;/code&gt; and &lt;code&gt;offset&lt;/code&gt; parameters. Additionally, parameter queries can be added to a request to limit the results.
func (r ApiPrismTransparencyDatabaseRequest) Limit(limit string) ApiPrismTransparencyDatabaseRequest {
	r.limit = &limit
	return r
}

// Specify the starting record to return.
func (r ApiPrismTransparencyDatabaseRequest) Offset(offset string) ApiPrismTransparencyDatabaseRequest {
	r.offset = &offset
	return r
}

func (r ApiPrismTransparencyDatabaseRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.PrismTransparencyDatabaseExecute(r)
}

/*
PrismTransparencyDatabase Transparency database

Get Transparency Database (TCC) attributes for macOS.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPrismTransparencyDatabaseRequest
*/
func (a *PrismAPIService) PrismTransparencyDatabase(ctx context.Context) ApiPrismTransparencyDatabaseRequest {
	return ApiPrismTransparencyDatabaseRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *PrismAPIService) PrismTransparencyDatabaseExecute(r ApiPrismTransparencyDatabaseRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PrismAPIService.PrismTransparencyDatabase")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/prism/transparency_database"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.blueprintIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blueprint_ids", r.blueprintIds, "form", "")
	}
	if r.deviceFamilies != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "device_families", r.deviceFamilies, "form", "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", r.sortBy, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
