/*
Kandji API

<html><head></head><body><h1 id=&quot;welcome-to-the-kandji-api-documentation&quot;>Welcome to the Kandji API Documentation</h1> <p>You can find your API URL in Settings &gt; Access. The API URL will follow the below formats.</p> <ul> <li><p>US - <code>https://SubDomain.api.kandji.io</code></p> </li> <li><p>EU - <code>https://SubDomain.api.eu.kandji.io</code></p> </li> </ul> <p>For information on how to obtain an API token, please refer to the following support article.</p> <p><a href=&quot;https://support.kandji.io/api&quot;>https://support.kandji.io/api</a></p> <h4 id=&quot;rate-limit&quot;>Rate Limit</h4> <p>The Kandji API currently has an API rate limit of 10,000 requests per hour per customer.</p> <h4 id=&quot;request-methods&quot;>Request Methods</h4> <p>HTTP request methods supported by the Kandji API.</p> <div class=&quot;click-to-expand-wrapper is-table-wrapper&quot;><table> <thead> <tr> <th>Method</th> <th>Definition</th> </tr> </thead> <tbody> <tr> <td>GET</td> <td>The <code>GET</code> method requests a representation of the specified resource.</td> </tr> <tr> <td>POST</td> <td>The <code>POST</code> method submits an entity to the specified resource.</td> </tr> <tr> <td>PATCH</td> <td>The <code>PATCH</code> method applies partial modifications to a resource.</td> </tr> <tr> <td>DELETE</td> <td>The <code>DELETE</code> method deletes the specified resource.</td> </tr> </tbody> </table> </div><h4 id=&quot;response-codes&quot;>Response codes</h4> <p>Not all response codes apply to every endpoint.</p> <div class=&quot;click-to-expand-wrapper is-table-wrapper&quot;><table> <thead> <tr> <th>Code</th> <th>Response</th> </tr> </thead> <tbody> <tr> <td>200</td> <td>OK</td> </tr> <tr> <td>201</td> <td>Created</td> </tr> <tr> <td>204</td> <td>No content</td> </tr> <tr> <td></td> <td>Typical response when sending the DELETE method.</td> </tr> <tr> <td>400</td> <td>Bad Request</td> </tr> <tr> <td></td> <td>&quot;Command already running&quot; - The command may already be running in a <em>Pending</em> state waiting on the device.</td> </tr> <tr> <td></td> <td>&quot;Command is not allowed for current device&quot; - The command may not be compatible with the target device.</td> </tr> <tr> <td></td> <td>&quot;JSON parse error - Expecting ',' delimiter: line 3 column 2 (char 65)&quot;</td> </tr> <tr> <td>401</td> <td>Unauthorized</td> </tr> <tr> <td></td> <td>This error can occur if the token is incorrect, was revoked, or the token has expired.</td> </tr> <tr> <td>403</td> <td>Forbidden</td> </tr> <tr> <td></td> <td>The request was understood but cannot be authorized.</td> </tr> <tr> <td>404</td> <td>Not found</td> </tr> <tr> <td></td> <td>Unable to locate the resource in the Kandji tenant.</td> </tr> <tr> <td>415</td> <td>Unsupported Media Type</td> </tr> <tr> <td></td> <td>The request contains a media type which the server or resource does not support.</td> </tr> <tr> <td>500</td> <td>Internal server error</td> </tr> <tr> <td>503</td> <td>Service unavailable</td> </tr> <tr> <td></td> <td>This error can occur if a file upload is still being processed via the custom apps API.</td> </tr> </tbody> </table> </div><h4 id=&quot;data-structure&quot;>Data structure</h4> <p>The API returns all structured responses in JSON schema format.</p> <h4 id=&quot;examples&quot;>Examples</h4> <p>Code examples using the API can be found in the Kandji support <a href=&quot;https://github.com/kandji-inc/support/tree/main/api-tools&quot;>GitHub</a>.</p> </body></html>

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package kandji_sdk

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
)


// AutomatedDeviceEnrollmentIntegrationsAPIService AutomatedDeviceEnrollmentIntegrationsAPI service
type AutomatedDeviceEnrollmentIntegrationsAPIService service

type ApiCreateAdeIntegrationRequest struct {
	ctx context.Context
	ApiService *AutomatedDeviceEnrollmentIntegrationsAPIService
	blueprintId *string
	phone *string
	email *string
	file *os.File
}

func (r ApiCreateAdeIntegrationRequest) BlueprintId(blueprintId string) ApiCreateAdeIntegrationRequest {
	r.blueprintId = &blueprintId
	return r
}

func (r ApiCreateAdeIntegrationRequest) Phone(phone string) ApiCreateAdeIntegrationRequest {
	r.phone = &phone
	return r
}

func (r ApiCreateAdeIntegrationRequest) Email(email string) ApiCreateAdeIntegrationRequest {
	r.email = &email
	return r
}

// This is the MDM server token file(.p7m) download from ABM. Once downloaded from ABM, the file can be uploaded via API.
func (r ApiCreateAdeIntegrationRequest) File(file *os.File) ApiCreateAdeIntegrationRequest {
	r.file = file
	return r
}

func (r ApiCreateAdeIntegrationRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CreateAdeIntegrationExecute(r)
}

/*
CreateAdeIntegration Create ADE integration

<p>This request will create a new ADE integration.</p>
<p>The default <code>blueprint_id</code>, <code>phone</code> number, <code>email</code> address, and MDM server token <code>file</code> downloaded from ABM are required and must be sent in the request.</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAdeIntegrationRequest
*/
func (a *AutomatedDeviceEnrollmentIntegrationsAPIService) CreateAdeIntegration(ctx context.Context) ApiCreateAdeIntegrationRequest {
	return ApiCreateAdeIntegrationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *AutomatedDeviceEnrollmentIntegrationsAPIService) CreateAdeIntegrationExecute(r ApiCreateAdeIntegrationRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutomatedDeviceEnrollmentIntegrationsAPIService.CreateAdeIntegration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/apple/ade/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.blueprintId == nil {
		return localVarReturnValue, nil, reportError("blueprintId is required and must be specified")
	}
	if r.phone == nil {
		return localVarReturnValue, nil, reportError("phone is required and must be specified")
	}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.file == nil {
		return localVarReturnValue, nil, reportError("file is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "blueprint_id", r.blueprintId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "phone", r.phone, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "email", r.email, "", "")
	var fileLocalVarFormFileName string
	var fileLocalVarFileName     string
	var fileLocalVarFileBytes    []byte

	fileLocalVarFormFileName = "file"
	fileLocalVarFile := r.file

	if fileLocalVarFile != nil {
		fbs, _ := io.ReadAll(fileLocalVarFile)

		fileLocalVarFileBytes = fbs
		fileLocalVarFileName = fileLocalVarFile.Name()
		fileLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: fileLocalVarFileBytes, fileName: fileLocalVarFileName, formFileName: fileLocalVarFormFileName})
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteAdeIntegrationRequest struct {
	ctx context.Context
	ApiService *AutomatedDeviceEnrollmentIntegrationsAPIService
	adeTokenId string
}

func (r ApiDeleteAdeIntegrationRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteAdeIntegrationExecute(r)
}

/*
DeleteAdeIntegration Delete ADE integration

<h1 id=&quot;warning&quot;><strong>WARNING!</strong></h1>
<p>This is a HIGHLY destructive action.</p>
<p>Deleting an ADE token will unassign the associated device records from Kandji. For currently enrolled devices that were assigned to Kandji via the delete ADE integration will not be impacted until they are wiped and reprovisioned. This action is essentially the same as removing an ADE token from MDM and then adding it back.</p>
<p>If applicable, be sure to reassign the device records in ABM.</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param adeTokenId
 @return ApiDeleteAdeIntegrationRequest
*/
func (a *AutomatedDeviceEnrollmentIntegrationsAPIService) DeleteAdeIntegration(ctx context.Context, adeTokenId string) ApiDeleteAdeIntegrationRequest {
	return ApiDeleteAdeIntegrationRequest{
		ApiService: a,
		ctx: ctx,
		adeTokenId: adeTokenId,
	}
}

// Execute executes the request
func (a *AutomatedDeviceEnrollmentIntegrationsAPIService) DeleteAdeIntegrationExecute(r ApiDeleteAdeIntegrationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutomatedDeviceEnrollmentIntegrationsAPIService.DeleteAdeIntegration")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/apple/ade/{ade_token_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"ade_token_id"+"}", url.PathEscape(parameterValueToString(r.adeTokenId, "adeTokenId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDownloadAdePublicKeyRequest struct {
	ctx context.Context
	ApiService *AutomatedDeviceEnrollmentIntegrationsAPIService
}

func (r ApiDownloadAdePublicKeyRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.DownloadAdePublicKeyExecute(r)
}

/*
DownloadAdePublicKey Download ADE public key

<p>This request returns the public key used to create an MDM server connection in Apple Business Manager.</p>
<p>The encoded information needs to be saved to a file with the <code>.pem</code> format and then uploaded to ABM.</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDownloadAdePublicKeyRequest
*/
func (a *AutomatedDeviceEnrollmentIntegrationsAPIService) DownloadAdePublicKey(ctx context.Context) ApiDownloadAdePublicKeyRequest {
	return ApiDownloadAdePublicKeyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *AutomatedDeviceEnrollmentIntegrationsAPIService) DownloadAdePublicKeyExecute(r ApiDownloadAdePublicKeyRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutomatedDeviceEnrollmentIntegrationsAPIService.DownloadAdePublicKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/apple/ade/public_key/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-x509-ca-cert"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAdeDeviceRequest struct {
	ctx context.Context
	ApiService *AutomatedDeviceEnrollmentIntegrationsAPIService
	deviceId string
}

func (r ApiGetAdeDeviceRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetAdeDeviceExecute(r)
}

/*
GetAdeDevice Get ADE device

Get information about a specific Automated Device Enrollment device.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId
 @return ApiGetAdeDeviceRequest
*/
func (a *AutomatedDeviceEnrollmentIntegrationsAPIService) GetAdeDevice(ctx context.Context, deviceId string) ApiGetAdeDeviceRequest {
	return ApiGetAdeDeviceRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *AutomatedDeviceEnrollmentIntegrationsAPIService) GetAdeDeviceExecute(r ApiGetAdeDeviceRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutomatedDeviceEnrollmentIntegrationsAPIService.GetAdeDevice")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/apple/ade/devices/{device_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"device_id"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAdeIntegrationRequest struct {
	ctx context.Context
	ApiService *AutomatedDeviceEnrollmentIntegrationsAPIService
	adeTokenId string
}

func (r ApiGetAdeIntegrationRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetAdeIntegrationExecute(r)
}

/*
GetAdeIntegration Get ADE integration

This request returns a specific ADE integration based on the <code>ade_token_id</code> passed.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param adeTokenId
 @return ApiGetAdeIntegrationRequest
*/
func (a *AutomatedDeviceEnrollmentIntegrationsAPIService) GetAdeIntegration(ctx context.Context, adeTokenId string) ApiGetAdeIntegrationRequest {
	return ApiGetAdeIntegrationRequest{
		ApiService: a,
		ctx: ctx,
		adeTokenId: adeTokenId,
	}
}

// Execute executes the request
func (a *AutomatedDeviceEnrollmentIntegrationsAPIService) GetAdeIntegrationExecute(r ApiGetAdeIntegrationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutomatedDeviceEnrollmentIntegrationsAPIService.GetAdeIntegration")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/apple/ade/{ade_token_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"ade_token_id"+"}", url.PathEscape(parameterValueToString(r.adeTokenId, "adeTokenId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiListAdeDevicesRequest struct {
	ctx context.Context
	ApiService *AutomatedDeviceEnrollmentIntegrationsAPIService
	blueprintId *string
	userId *string
	depAccount *string
	deviceFamily *string
	model *string
	os *string
	profileStatus *string
	serialNumber *string
	page *string
}

// Return results &amp;quot;containing&amp;quot; the specified blueprint id
func (r ApiListAdeDevicesRequest) BlueprintId(blueprintId string) ApiListAdeDevicesRequest {
	r.blueprintId = &blueprintId
	return r
}

// &amp;quot;exact&amp;quot; match on kandji user ID number
func (r ApiListAdeDevicesRequest) UserId(userId string) ApiListAdeDevicesRequest {
	r.userId = &userId
	return r
}

// The ADE token UUID
func (r ApiListAdeDevicesRequest) DepAccount(depAccount string) ApiListAdeDevicesRequest {
	r.depAccount = &depAccount
	return r
}

// Mac, iPhone, iPad, AppleTV, iPod
func (r ApiListAdeDevicesRequest) DeviceFamily(deviceFamily string) ApiListAdeDevicesRequest {
	r.deviceFamily = &deviceFamily
	return r
}

// Return model results &amp;quot;containing&amp;quot; the specified model string. - &amp;quot;iPad (8th Generation)&amp;quot;, &amp;quot;MacBook Air&amp;quot;
func (r ApiListAdeDevicesRequest) Model(model string) ApiListAdeDevicesRequest {
	r.model = &model
	return r
}

// OSX, iOS, tvOS
func (r ApiListAdeDevicesRequest) Os(os string) ApiListAdeDevicesRequest {
	r.os = &os
	return r
}

// The automated device enrollment profile assignment status - assigned, empty, pushed, removed
func (r ApiListAdeDevicesRequest) ProfileStatus(profileStatus string) ApiListAdeDevicesRequest {
	r.profileStatus = &profileStatus
	return r
}

// Search for a specific device by Serial Number. If partial serial number is provided in the query, all device containing the partial string will be returned.
func (r ApiListAdeDevicesRequest) SerialNumber(serialNumber string) ApiListAdeDevicesRequest {
	r.serialNumber = &serialNumber
	return r
}

// Use the &lt;code&gt;page&lt;/code&gt; parameter to page through results or to request a specific page. By default, if a page is not specified, page 1 is returned. Note: 300 device records are returned per page of results. Alternatively, the &lt;code&gt;next&lt;/code&gt; and &lt;code&gt;previous&lt;/code&gt; key attributes in the response can be used to request the next page of results or return to the previous page.
func (r ApiListAdeDevicesRequest) Page(page string) ApiListAdeDevicesRequest {
	r.page = &page
	return r
}

func (r ApiListAdeDevicesRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ListAdeDevicesExecute(r)
}

/*
ListAdeDevices List ADE devices

Get a list of Automated Device Enrollment devices.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListAdeDevicesRequest
*/
func (a *AutomatedDeviceEnrollmentIntegrationsAPIService) ListAdeDevices(ctx context.Context) ApiListAdeDevicesRequest {
	return ApiListAdeDevicesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *AutomatedDeviceEnrollmentIntegrationsAPIService) ListAdeDevicesExecute(r ApiListAdeDevicesRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutomatedDeviceEnrollmentIntegrationsAPIService.ListAdeDevices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/apple/ade/devices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.blueprintId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blueprint_id", r.blueprintId, "form", "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user_id", r.userId, "form", "")
	}
	if r.depAccount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dep_account", r.depAccount, "form", "")
	}
	if r.deviceFamily != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "device_family", r.deviceFamily, "form", "")
	}
	if r.model != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "model", r.model, "form", "")
	}
	if r.os != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "os", r.os, "form", "")
	}
	if r.profileStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profile_status", r.profileStatus, "form", "")
	}
	if r.serialNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "serial_number", r.serialNumber, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListAdeIntegrationsRequest struct {
	ctx context.Context
	ApiService *AutomatedDeviceEnrollmentIntegrationsAPIService
}

func (r ApiListAdeIntegrationsRequest) Execute() (*http.Response, error) {
	return r.ApiService.ListAdeIntegrationsExecute(r)
}

/*
ListAdeIntegrations List ADE integrations

This request returns a list of configured ADE integrations.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListAdeIntegrationsRequest
*/
func (a *AutomatedDeviceEnrollmentIntegrationsAPIService) ListAdeIntegrations(ctx context.Context) ApiListAdeIntegrationsRequest {
	return ApiListAdeIntegrationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *AutomatedDeviceEnrollmentIntegrationsAPIService) ListAdeIntegrationsExecute(r ApiListAdeIntegrationsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutomatedDeviceEnrollmentIntegrationsAPIService.ListAdeIntegrations")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/apple/ade"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiListDevicesAssociatedToAdeTokenRequest struct {
	ctx context.Context
	ApiService *AutomatedDeviceEnrollmentIntegrationsAPIService
	adeTokenId string
	page *string
}

// Use the &lt;code&gt;page&lt;/code&gt; parameter to page through results or to request a specific page. By default, if a page is not specified, page 1 is returned. Note: 300 device records are returned per page of results. Alternatively, the &lt;code&gt;next&lt;/code&gt; and &lt;code&gt;previous&lt;/code&gt; key attributes in the response can be used to request the next page of results or return to the previous page.
func (r ApiListDevicesAssociatedToAdeTokenRequest) Page(page string) ApiListDevicesAssociatedToAdeTokenRequest {
	r.page = &page
	return r
}

func (r ApiListDevicesAssociatedToAdeTokenRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ListDevicesAssociatedToAdeTokenExecute(r)
}

/*
ListDevicesAssociatedToAdeToken List devices associated to ADE token

<p>This request returns a list of devices associated with a specified <code>ade_token_id</code> as well as their enrollment status.</p>
<p>When the <code>mdm_device</code> key value is <code>null</code>, this can be taken as an indication that the device is awaiting enrollment into Kandji.</p>
<p>When data is present within the mdm_device dictionary, you can reference the <code>device_id</code> as the ID of the enrolled device record.</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param adeTokenId
 @return ApiListDevicesAssociatedToAdeTokenRequest
*/
func (a *AutomatedDeviceEnrollmentIntegrationsAPIService) ListDevicesAssociatedToAdeToken(ctx context.Context, adeTokenId string) ApiListDevicesAssociatedToAdeTokenRequest {
	return ApiListDevicesAssociatedToAdeTokenRequest{
		ApiService: a,
		ctx: ctx,
		adeTokenId: adeTokenId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *AutomatedDeviceEnrollmentIntegrationsAPIService) ListDevicesAssociatedToAdeTokenExecute(r ApiListDevicesAssociatedToAdeTokenRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutomatedDeviceEnrollmentIntegrationsAPIService.ListDevicesAssociatedToAdeToken")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/apple/ade/{ade_token_id}/devices"
	localVarPath = strings.Replace(localVarPath, "{"+"ade_token_id"+"}", url.PathEscape(parameterValueToString(r.adeTokenId, "adeTokenId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRenewAdeIntegrationRequest struct {
	ctx context.Context
	ApiService *AutomatedDeviceEnrollmentIntegrationsAPIService
	adeTokenId string
	blueprintId *string
	phone *string
	email *string
	file *os.File
}

func (r ApiRenewAdeIntegrationRequest) BlueprintId(blueprintId string) ApiRenewAdeIntegrationRequest {
	r.blueprintId = &blueprintId
	return r
}

func (r ApiRenewAdeIntegrationRequest) Phone(phone string) ApiRenewAdeIntegrationRequest {
	r.phone = &phone
	return r
}

func (r ApiRenewAdeIntegrationRequest) Email(email string) ApiRenewAdeIntegrationRequest {
	r.email = &email
	return r
}

// This is the MDM server token file(.p7m) download from ABM. Once downloaded from ABM, the file can be uploaded via API.
func (r ApiRenewAdeIntegrationRequest) File(file *os.File) ApiRenewAdeIntegrationRequest {
	r.file = file
	return r
}

func (r ApiRenewAdeIntegrationRequest) Execute() (*http.Response, error) {
	return r.ApiService.RenewAdeIntegrationExecute(r)
}

/*
RenewAdeIntegration Renew ADE integration

<p>This request will renew an existing ADE integration.</p>
<p>The default <code>blueprint_id</code>, <code>phone</code> number, <code>email</code> address, and MDM server token <code>file</code> from the associated MDM server in ABM are required and must be sent in the request.</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param adeTokenId
 @return ApiRenewAdeIntegrationRequest
*/
func (a *AutomatedDeviceEnrollmentIntegrationsAPIService) RenewAdeIntegration(ctx context.Context, adeTokenId string) ApiRenewAdeIntegrationRequest {
	return ApiRenewAdeIntegrationRequest{
		ApiService: a,
		ctx: ctx,
		adeTokenId: adeTokenId,
	}
}

// Execute executes the request
func (a *AutomatedDeviceEnrollmentIntegrationsAPIService) RenewAdeIntegrationExecute(r ApiRenewAdeIntegrationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutomatedDeviceEnrollmentIntegrationsAPIService.RenewAdeIntegration")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/apple/ade/{ade_token_id}/renew"
	localVarPath = strings.Replace(localVarPath, "{"+"ade_token_id"+"}", url.PathEscape(parameterValueToString(r.adeTokenId, "adeTokenId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.blueprintId == nil {
		return nil, reportError("blueprintId is required and must be specified")
	}
	if r.phone == nil {
		return nil, reportError("phone is required and must be specified")
	}
	if r.email == nil {
		return nil, reportError("email is required and must be specified")
	}
	if r.file == nil {
		return nil, reportError("file is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "blueprint_id", r.blueprintId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "phone", r.phone, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "email", r.email, "", "")
	var fileLocalVarFormFileName string
	var fileLocalVarFileName     string
	var fileLocalVarFileBytes    []byte

	fileLocalVarFormFileName = "file"
	fileLocalVarFile := r.file

	if fileLocalVarFile != nil {
		fbs, _ := io.ReadAll(fileLocalVarFile)

		fileLocalVarFileBytes = fbs
		fileLocalVarFileName = fileLocalVarFile.Name()
		fileLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: fileLocalVarFileBytes, fileName: fileLocalVarFileName, formFileName: fileLocalVarFormFileName})
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateAdeDeviceRequest struct {
	ctx context.Context
	ApiService *AutomatedDeviceEnrollmentIntegrationsAPIService
	deviceId string
	body *string
}

func (r ApiUpdateAdeDeviceRequest) Body(body string) ApiUpdateAdeDeviceRequest {
	r.body = &body
	return r
}

func (r ApiUpdateAdeDeviceRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.UpdateAdeDeviceExecute(r)
}

/*
UpdateAdeDevice Update ADE device

<p>Update a specific Automated Device Enrollment device's blueprint assignment, user assignment, and asset tag.</p>
<h3 id=&quot;request-parameters&quot;>Request Parameters</h3>
<p><code>device_id</code> (path parameter): The unique identifier of the device.</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId
 @return ApiUpdateAdeDeviceRequest
*/
func (a *AutomatedDeviceEnrollmentIntegrationsAPIService) UpdateAdeDevice(ctx context.Context, deviceId string) ApiUpdateAdeDeviceRequest {
	return ApiUpdateAdeDeviceRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *AutomatedDeviceEnrollmentIntegrationsAPIService) UpdateAdeDeviceExecute(r ApiUpdateAdeDeviceRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutomatedDeviceEnrollmentIntegrationsAPIService.UpdateAdeDevice")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/apple/ade/devices/{device_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"device_id"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateAdeIntegrationRequest struct {
	ctx context.Context
	ApiService *AutomatedDeviceEnrollmentIntegrationsAPIService
	adeTokenId string
	body *string
}

func (r ApiUpdateAdeIntegrationRequest) Body(body string) ApiUpdateAdeIntegrationRequest {
	r.body = &body
	return r
}

func (r ApiUpdateAdeIntegrationRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateAdeIntegrationExecute(r)
}

/*
UpdateAdeIntegration Update ADE integration

<p>This request will update the default blueprint, phone number, and email address in an existing ADE integration.</p>
<p>The default <code>blueprint_id</code>, <code>phone</code> number, and <code>email</code> address must be sent in the request.</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param adeTokenId
 @return ApiUpdateAdeIntegrationRequest
*/
func (a *AutomatedDeviceEnrollmentIntegrationsAPIService) UpdateAdeIntegration(ctx context.Context, adeTokenId string) ApiUpdateAdeIntegrationRequest {
	return ApiUpdateAdeIntegrationRequest{
		ApiService: a,
		ctx: ctx,
		adeTokenId: adeTokenId,
	}
}

// Execute executes the request
func (a *AutomatedDeviceEnrollmentIntegrationsAPIService) UpdateAdeIntegrationExecute(r ApiUpdateAdeIntegrationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutomatedDeviceEnrollmentIntegrationsAPIService.UpdateAdeIntegration")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/apple/ade/{ade_token_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"ade_token_id"+"}", url.PathEscape(parameterValueToString(r.adeTokenId, "adeTokenId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
