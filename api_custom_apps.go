/*
Kandji API

<html><head></head><body><h1 id=&quot;welcome-to-the-kandji-api-documentation&quot;>Welcome to the Kandji API Documentation</h1> <p>You can find your API URL in Settings &gt; Access. The API URL will follow the below formats.</p> <ul> <li><p>US - <code>https://SubDomain.api.kandji.io</code></p> </li> <li><p>EU - <code>https://SubDomain.api.eu.kandji.io</code></p> </li> </ul> <p>For information on how to obtain an API token, please refer to the following support article.</p> <p><a href=&quot;https://support.kandji.io/api&quot;>https://support.kandji.io/api</a></p> <h4 id=&quot;rate-limit&quot;>Rate Limit</h4> <p>The Kandji API currently has an API rate limit of 10,000 requests per hour per customer.</p> <h4 id=&quot;request-methods&quot;>Request Methods</h4> <p>HTTP request methods supported by the Kandji API.</p> <div class=&quot;click-to-expand-wrapper is-table-wrapper&quot;><table> <thead> <tr> <th>Method</th> <th>Definition</th> </tr> </thead> <tbody> <tr> <td>GET</td> <td>The <code>GET</code> method requests a representation of the specified resource.</td> </tr> <tr> <td>POST</td> <td>The <code>POST</code> method submits an entity to the specified resource.</td> </tr> <tr> <td>PATCH</td> <td>The <code>PATCH</code> method applies partial modifications to a resource.</td> </tr> <tr> <td>DELETE</td> <td>The <code>DELETE</code> method deletes the specified resource.</td> </tr> </tbody> </table> </div><h4 id=&quot;response-codes&quot;>Response codes</h4> <p>Not all response codes apply to every endpoint.</p> <div class=&quot;click-to-expand-wrapper is-table-wrapper&quot;><table> <thead> <tr> <th>Code</th> <th>Response</th> </tr> </thead> <tbody> <tr> <td>200</td> <td>OK</td> </tr> <tr> <td>201</td> <td>Created</td> </tr> <tr> <td>204</td> <td>No content</td> </tr> <tr> <td></td> <td>Typical response when sending the DELETE method.</td> </tr> <tr> <td>400</td> <td>Bad Request</td> </tr> <tr> <td></td> <td>&quot;Command already running&quot; - The command may already be running in a <em>Pending</em> state waiting on the device.</td> </tr> <tr> <td></td> <td>&quot;Command is not allowed for current device&quot; - The command may not be compatible with the target device.</td> </tr> <tr> <td></td> <td>&quot;JSON parse error - Expecting ',' delimiter: line 3 column 2 (char 65)&quot;</td> </tr> <tr> <td>401</td> <td>Unauthorized</td> </tr> <tr> <td></td> <td>This error can occur if the token is incorrect, was revoked, or the token has expired.</td> </tr> <tr> <td>403</td> <td>Forbidden</td> </tr> <tr> <td></td> <td>The request was understood but cannot be authorized.</td> </tr> <tr> <td>404</td> <td>Not found</td> </tr> <tr> <td></td> <td>Unable to locate the resource in the Kandji tenant.</td> </tr> <tr> <td>415</td> <td>Unsupported Media Type</td> </tr> <tr> <td></td> <td>The request contains a media type which the server or resource does not support.</td> </tr> <tr> <td>500</td> <td>Internal server error</td> </tr> <tr> <td>503</td> <td>Service unavailable</td> </tr> <tr> <td></td> <td>This error can occur if a file upload is still being processed via the custom apps API.</td> </tr> </tbody> </table> </div><h4 id=&quot;data-structure&quot;>Data structure</h4> <p>The API returns all structured responses in JSON schema format.</p> <h4 id=&quot;examples&quot;>Examples</h4> <p>Code examples using the API can be found in the Kandji support <a href=&quot;https://github.com/kandji-inc/support/tree/main/api-tools&quot;>GitHub</a>.</p> </body></html>

API version: 1.0.0
Contact: mitchelsblake@gmail.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package kandji_sdk

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// CustomAppsAPIService CustomAppsAPI service
type CustomAppsAPIService service

type ApiCustomAppsCreateCustomAppRequest struct {
	ctx context.Context
	ApiService *CustomAppsAPIService
	name *string
	fileKey *string
	installType *string
	installEnforcement *string
	showInSelfService *string
	selfServiceCategoryId *string
	selfServiceRecommended *string
}

// (Required) The name for this Custom App
func (r ApiCustomAppsCreateCustomAppRequest) Name(name string) ApiCustomAppsCreateCustomAppRequest {
	r.name = &name
	return r
}

// (Required) The S3 key from the &lt;code&gt;Upload Custom App&lt;/code&gt; endpont used to upload the custom app file.
func (r ApiCustomAppsCreateCustomAppRequest) FileKey(fileKey string) ApiCustomAppsCreateCustomAppRequest {
	r.fileKey = &fileKey
	return r
}

// (Required) Options are package, zip, image
func (r ApiCustomAppsCreateCustomAppRequest) InstallType(installType string) ApiCustomAppsCreateCustomAppRequest {
	r.installType = &installType
	return r
}

// (Required) Options are install_once, continuously_enforce, no_enforcement
func (r ApiCustomAppsCreateCustomAppRequest) InstallEnforcement(installEnforcement string) ApiCustomAppsCreateCustomAppRequest {
	r.installEnforcement = &installEnforcement
	return r
}

// (Optional, default&#x3D;false) Displays this app in Self Service
func (r ApiCustomAppsCreateCustomAppRequest) ShowInSelfService(showInSelfService string) ApiCustomAppsCreateCustomAppRequest {
	r.showInSelfService = &showInSelfService
	return r
}

// (Required for show_in_self_service&#x3D;true) Self Service Category (by ID) to display app in
func (r ApiCustomAppsCreateCustomAppRequest) SelfServiceCategoryId(selfServiceCategoryId string) ApiCustomAppsCreateCustomAppRequest {
	r.selfServiceCategoryId = &selfServiceCategoryId
	return r
}

// (Optional, default&#x3D;false) Adds recommended flag to app in Self Service
func (r ApiCustomAppsCreateCustomAppRequest) SelfServiceRecommended(selfServiceRecommended string) ApiCustomAppsCreateCustomAppRequest {
	r.selfServiceRecommended = &selfServiceRecommended
	return r
}

func (r ApiCustomAppsCreateCustomAppRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CustomAppsCreateCustomAppExecute(r)
}

/*
CustomAppsCreateCustomApp Create Custom App

<p>This request allows you to create a custom app in the Kandji library.</p>
<p>Must have already generated a <code>file_key</code> via <code>Create custom app</code> endpoint and uploaded the file to S3 using a request similar to the <code>Upload to S3</code> example.</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCustomAppsCreateCustomAppRequest
*/
func (a *CustomAppsAPIService) CustomAppsCreateCustomApp(ctx context.Context) ApiCustomAppsCreateCustomAppRequest {
	return ApiCustomAppsCreateCustomAppRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *CustomAppsAPIService) CustomAppsCreateCustomAppExecute(r ApiCustomAppsCreateCustomAppRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomAppsAPIService.CustomAppsCreateCustomApp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/library/custom-apps"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.name == nil {
		return localVarReturnValue, nil, reportError("name is required and must be specified")
	}
	if r.fileKey == nil {
		return localVarReturnValue, nil, reportError("fileKey is required and must be specified")
	}
	if r.installType == nil {
		return localVarReturnValue, nil, reportError("installType is required and must be specified")
	}
	if r.installEnforcement == nil {
		return localVarReturnValue, nil, reportError("installEnforcement is required and must be specified")
	}
	if r.showInSelfService == nil {
		return localVarReturnValue, nil, reportError("showInSelfService is required and must be specified")
	}
	if r.selfServiceCategoryId == nil {
		return localVarReturnValue, nil, reportError("selfServiceCategoryId is required and must be specified")
	}
	if r.selfServiceRecommended == nil {
		return localVarReturnValue, nil, reportError("selfServiceRecommended is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "name", r.name, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "file_key", r.fileKey, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "install_type", r.installType, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "install_enforcement", r.installEnforcement, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "show_in_self_service", r.showInSelfService, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "self_service_category_id", r.selfServiceCategoryId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "self_service_recommended", r.selfServiceRecommended, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCustomAppsDeleteCustomAppRequest struct {
	ctx context.Context
	ApiService *CustomAppsAPIService
	libraryItemId string
}

func (r ApiCustomAppsDeleteCustomAppRequest) Execute() (*http.Response, error) {
	return r.ApiService.CustomAppsDeleteCustomAppExecute(r)
}

/*
CustomAppsDeleteCustomApp Delete Custom App

<p>NOTICE: This is permanent so be careful.</p>
<p>This endpoint sends a request to delete a specific custom app from the Kandji library.</p>
<h3 id=&quot;request-parameters&quot;>Request Parameters</h3>
<p><code>library_item_id</code> (path parameter): The unique identifier of the library item.</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param libraryItemId
 @return ApiCustomAppsDeleteCustomAppRequest
*/
func (a *CustomAppsAPIService) CustomAppsDeleteCustomApp(ctx context.Context, libraryItemId string) ApiCustomAppsDeleteCustomAppRequest {
	return ApiCustomAppsDeleteCustomAppRequest{
		ApiService: a,
		ctx: ctx,
		libraryItemId: libraryItemId,
	}
}

// Execute executes the request
func (a *CustomAppsAPIService) CustomAppsDeleteCustomAppExecute(r ApiCustomAppsDeleteCustomAppRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomAppsAPIService.CustomAppsDeleteCustomApp")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/library/custom-apps/{library_item_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"library_item_id"+"}", url.PathEscape(parameterValueToString(r.libraryItemId, "libraryItemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/html; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCustomAppsGetCustomAppRequest struct {
	ctx context.Context
	ApiService *CustomAppsAPIService
	libraryItemId string
}

func (r ApiCustomAppsGetCustomAppRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CustomAppsGetCustomAppExecute(r)
}

/*
CustomAppsGetCustomApp Get Custom App

<p>This endpoint retrieves details about a specific custom app from the Kandji library.</p>
<h3 id=&quot;request-parameters&quot;>Request Parameters</h3>
<p><code>library_item_id</code> (path parameter): The unique identifier of the library item.</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param libraryItemId
 @return ApiCustomAppsGetCustomAppRequest
*/
func (a *CustomAppsAPIService) CustomAppsGetCustomApp(ctx context.Context, libraryItemId string) ApiCustomAppsGetCustomAppRequest {
	return ApiCustomAppsGetCustomAppRequest{
		ApiService: a,
		ctx: ctx,
		libraryItemId: libraryItemId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *CustomAppsAPIService) CustomAppsGetCustomAppExecute(r ApiCustomAppsGetCustomAppRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomAppsAPIService.CustomAppsGetCustomApp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/library/custom-apps/{library_item_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"library_item_id"+"}", url.PathEscape(parameterValueToString(r.libraryItemId, "libraryItemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCustomAppsListCustomAppsRequest struct {
	ctx context.Context
	ApiService *CustomAppsAPIService
	page *string
}

// Optional page number. Used when results exceed pagination threshold. A hard upper &lt;code&gt;limit&lt;/code&gt; is set at 300 device records returned per request.
func (r ApiCustomAppsListCustomAppsRequest) Page(page string) ApiCustomAppsListCustomAppsRequest {
	r.page = &page
	return r
}

func (r ApiCustomAppsListCustomAppsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CustomAppsListCustomAppsExecute(r)
}

/*
CustomAppsListCustomApps List Custom Apps

This endpoint makes a request to retrieve a list of custom apps from the Kandji library.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCustomAppsListCustomAppsRequest
*/
func (a *CustomAppsAPIService) CustomAppsListCustomApps(ctx context.Context) ApiCustomAppsListCustomAppsRequest {
	return ApiCustomAppsListCustomAppsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *CustomAppsAPIService) CustomAppsListCustomAppsExecute(r ApiCustomAppsListCustomAppsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomAppsAPIService.CustomAppsListCustomApps")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/library/custom-apps"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCustomAppsUpdateCustomAppRequest struct {
	ctx context.Context
	ApiService *CustomAppsAPIService
	libraryItemId string
	name *string
	active *string
}

// Renaming a Custom App
func (r ApiCustomAppsUpdateCustomAppRequest) Name(name string) ApiCustomAppsUpdateCustomAppRequest {
	r.name = &name
	return r
}

// (Optional, default&#x3D;true) Whether this Custom App is active and installable
func (r ApiCustomAppsUpdateCustomAppRequest) Active(active string) ApiCustomAppsUpdateCustomAppRequest {
	r.active = &active
	return r
}

func (r ApiCustomAppsUpdateCustomAppRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CustomAppsUpdateCustomAppExecute(r)
}

/*
CustomAppsUpdateCustomApp Update Custom App

<p>This request allows you to update a custom app in the Kandji library.</p>
<p>Must have already generated a <code>file_key</code> via <code>Create custom app</code> endpoint and uploaded the file to S3 using a request similar to the <code>Upload to S3</code> example.</p>
<h3 id=&quot;request-parameters&quot;>Request Parameters</h3>
<p><code>library_item_id</code> (path parameter): The unique identifier of the library item.</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param libraryItemId
 @return ApiCustomAppsUpdateCustomAppRequest
*/
func (a *CustomAppsAPIService) CustomAppsUpdateCustomApp(ctx context.Context, libraryItemId string) ApiCustomAppsUpdateCustomAppRequest {
	return ApiCustomAppsUpdateCustomAppRequest{
		ApiService: a,
		ctx: ctx,
		libraryItemId: libraryItemId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *CustomAppsAPIService) CustomAppsUpdateCustomAppExecute(r ApiCustomAppsUpdateCustomAppRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomAppsAPIService.CustomAppsUpdateCustomApp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/library/custom-apps/{library_item_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"library_item_id"+"}", url.PathEscape(parameterValueToString(r.libraryItemId, "libraryItemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.name == nil {
		return localVarReturnValue, nil, reportError("name is required and must be specified")
	}
	if r.active == nil {
		return localVarReturnValue, nil, reportError("active is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "name", r.name, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "active", r.active, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCustomAppsUploadCustomAppRequest struct {
	ctx context.Context
	ApiService *CustomAppsAPIService
	body *string
}

func (r ApiCustomAppsUploadCustomAppRequest) Body(body string) ApiCustomAppsUploadCustomAppRequest {
	r.body = &body
	return r
}

func (r ApiCustomAppsUploadCustomAppRequest) Execute() (*http.Response, error) {
	return r.ApiService.CustomAppsUploadCustomAppExecute(r)
}

/*
CustomAppsUploadCustomApp Upload Custom App

<p>This request retrieves the S3 upload details need for uploading the app to Amazon S3.</p>
<p>Creates a pre-signed <code>post_url</code> to upload a new Custom App to S3.</p>
<p>The provided <code>name</code> will be used to calculate a unique <code>file_key</code> in S3.</p>
<p>A separate request will have to be made to the <code>Upload to S3</code> endpoint to upload the file to S3 directly using the <code>post_url</code> and <code>post_data</code> from the <code>Upload Custom App</code> response.</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCustomAppsUploadCustomAppRequest
*/
func (a *CustomAppsAPIService) CustomAppsUploadCustomApp(ctx context.Context) ApiCustomAppsUploadCustomAppRequest {
	return ApiCustomAppsUploadCustomAppRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *CustomAppsAPIService) CustomAppsUploadCustomAppExecute(r ApiCustomAppsUploadCustomAppRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomAppsAPIService.CustomAppsUploadCustomApp")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/library/custom-apps/upload"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
