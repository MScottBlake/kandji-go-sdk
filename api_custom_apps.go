/*
Kandji API

<html><head></head><body><h1 id=&quot;welcome-to-the-kandji-api-documentation&quot;>Welcome to the Kandji API Documentation</h1> <p>You can find your API URL in Settings &gt; Access. The API URL will follow the below formats.</p> <ul> <li><p>US - <code>https://SubDomain.api.kandji.io</code></p> </li> <li><p>EU - <code>https://SubDomain.api.eu.kandji.io</code></p> </li> </ul> <p>For information on how to obtain an API token, please refer to the following support article.</p> <p><a href=&quot;https://support.kandji.io/api&quot;>https://support.kandji.io/api</a></p> <h4 id=&quot;rate-limit&quot;>Rate Limit</h4> <p>The Kandji API currently has an API rate limit of 10,000 requests per hour per customer.</p> <h4 id=&quot;request-methods&quot;>Request Methods</h4> <p>HTTP request methods supported by the Kandji API.</p> <div class=&quot;click-to-expand-wrapper is-table-wrapper&quot;><table> <thead> <tr> <th>Method</th> <th>Definition</th> </tr> </thead> <tbody> <tr> <td>GET</td> <td>The <code>GET</code> method requests a representation of the specified resource.</td> </tr> <tr> <td>POST</td> <td>The <code>POST</code> method submits an entity to the specified resource.</td> </tr> <tr> <td>PATCH</td> <td>The <code>PATCH</code> method applies partial modifications to a resource.</td> </tr> <tr> <td>DELETE</td> <td>The <code>DELETE</code> method deletes the specified resource.</td> </tr> </tbody> </table> </div><h4 id=&quot;response-codes&quot;>Response codes</h4> <p>Not all response codes apply to every endpoint.</p> <div class=&quot;click-to-expand-wrapper is-table-wrapper&quot;><table> <thead> <tr> <th>Code</th> <th>Response</th> </tr> </thead> <tbody> <tr> <td>200</td> <td>OK</td> </tr> <tr> <td>201</td> <td>Created</td> </tr> <tr> <td>204</td> <td>No content</td> </tr> <tr> <td></td> <td>Typical response when sending the DELETE method.</td> </tr> <tr> <td>400</td> <td>Bad Request</td> </tr> <tr> <td></td> <td>&quot;Command already running&quot; - The command may already be running in a <em>Pending</em> state waiting on the device.</td> </tr> <tr> <td></td> <td>&quot;Command is not allowed for current device&quot; - The command may not be compatible with the target device.</td> </tr> <tr> <td></td> <td>&quot;JSON parse error - Expecting ',' delimiter: line 3 column 2 (char 65)&quot;</td> </tr> <tr> <td>401</td> <td>Unauthorized</td> </tr> <tr> <td></td> <td>This error can occur if the token is incorrect, was revoked, or the token has expired.</td> </tr> <tr> <td>403</td> <td>Forbidden</td> </tr> <tr> <td></td> <td>The request was understood but cannot be authorized.</td> </tr> <tr> <td>404</td> <td>Not found</td> </tr> <tr> <td></td> <td>Unable to locate the resource in the Kandji tenant.</td> </tr> <tr> <td>415</td> <td>Unsupported Media Type</td> </tr> <tr> <td></td> <td>The request contains a media type which the server or resource does not support.</td> </tr> <tr> <td>500</td> <td>Internal server error</td> </tr> <tr> <td>503</td> <td>Service unavailable</td> </tr> <tr> <td></td> <td>This error can occur if a file upload is still being processed via the custom apps API.</td> </tr> </tbody> </table> </div><h4 id=&quot;data-structure&quot;>Data structure</h4> <p>The API returns all structured responses in JSON schema format.</p> <h4 id=&quot;examples&quot;>Examples</h4> <p>Code examples using the API can be found in the Kandji support <a href=&quot;https://github.com/kandji-inc/support/tree/main/api-tools&quot;>GitHub</a>.</p> </body></html>

API version: 1.0.0
Contact: mitchelsblake@gmail.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package kandji

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type CustomAppsAPI interface {

	/*
	CreateCustomApp Create Custom App

	<p>This request allows you to create a custom app in the Kandji library.</p>
<p>Must have already generated a <code>file_key</code> via <code>Create custom app</code> endpoint and uploaded the file to S3 using a request similar to the <code>Upload to S3</code> example.</p>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateCustomAppRequest
	*/
	CreateCustomApp(ctx context.Context) ApiCreateCustomAppRequest

	// CreateCustomAppExecute executes the request
	//  @return map[string]interface{}
	CreateCustomAppExecute(r ApiCreateCustomAppRequest) (map[string]interface{}, *http.Response, error)

	/*
	DeleteCustomApp Delete Custom App

	<p>NOTICE: This is permanent so be careful.</p>
<p>This endpoint sends a request to delete a specific custom app from the Kandji library.</p>
<h3 id=&quot;request-parameters&quot;>Request Parameters</h3>
<p><code>library_item_id</code> (path parameter): The unique identifier of the library item.</p>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param libraryItemId
	@return ApiDeleteCustomAppRequest
	*/
	DeleteCustomApp(ctx context.Context, libraryItemId string) ApiDeleteCustomAppRequest

	// DeleteCustomAppExecute executes the request
	DeleteCustomAppExecute(r ApiDeleteCustomAppRequest) (*http.Response, error)

	/*
	GetCustomApp Get Custom App

	<p>This endpoint retrieves details about a specific custom app from the Kandji library.</p>
<h3 id=&quot;request-parameters&quot;>Request Parameters</h3>
<p><code>library_item_id</code> (path parameter): The unique identifier of the library item.</p>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param libraryItemId
	@return ApiGetCustomAppRequest
	*/
	GetCustomApp(ctx context.Context, libraryItemId string) ApiGetCustomAppRequest

	// GetCustomAppExecute executes the request
	//  @return map[string]interface{}
	GetCustomAppExecute(r ApiGetCustomAppRequest) (map[string]interface{}, *http.Response, error)

	/*
	ListCustomApps List Custom Apps

	This endpoint makes a request to retrieve a list of custom apps from the Kandji library.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListCustomAppsRequest
	*/
	ListCustomApps(ctx context.Context) ApiListCustomAppsRequest

	// ListCustomAppsExecute executes the request
	//  @return map[string]interface{}
	ListCustomAppsExecute(r ApiListCustomAppsRequest) (map[string]interface{}, *http.Response, error)

	/*
	UpdateCustomApp Update Custom App

	<p>This request allows you to update a custom app in the Kandji library.</p>
<p>Must have already generated a <code>file_key</code> via <code>Create custom app</code> endpoint and uploaded the file to S3 using a request similar to the <code>Upload to S3</code> example.</p>
<h3 id=&quot;request-parameters&quot;>Request Parameters</h3>
<p><code>library_item_id</code> (path parameter): The unique identifier of the library item.</p>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param libraryItemId
	@return ApiUpdateCustomAppRequest
	*/
	UpdateCustomApp(ctx context.Context, libraryItemId string) ApiUpdateCustomAppRequest

	// UpdateCustomAppExecute executes the request
	//  @return map[string]interface{}
	UpdateCustomAppExecute(r ApiUpdateCustomAppRequest) (map[string]interface{}, *http.Response, error)

	/*
	UploadCustomApp Upload Custom App

	<p>This request retrieves the S3 upload details need for uploading the app to Amazon S3.</p>
<p>Creates a pre-signed <code>post_url</code> to upload a new Custom App to S3.</p>
<p>The provided <code>name</code> will be used to calculate a unique <code>file_key</code> in S3.</p>
<p>A separate request will have to be made to the <code>Upload to S3</code> endpoint to upload the file to S3 directly using the <code>post_url</code> and <code>post_data</code> from the <code>Upload Custom App</code> response.</p>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUploadCustomAppRequest
	*/
	UploadCustomApp(ctx context.Context) ApiUploadCustomAppRequest

	// UploadCustomAppExecute executes the request
	UploadCustomAppExecute(r ApiUploadCustomAppRequest) (*http.Response, error)
}

// CustomAppsAPIService CustomAppsAPI service
type CustomAppsAPIService service

type ApiCreateCustomAppRequest struct {
	ctx context.Context
	ApiService CustomAppsAPI
	name *string
	fileKey *string
	installType *string
	installEnforcement *string
	showInSelfService *string
	selfServiceCategoryId *string
	selfServiceRecommended *string
}

// (Required) The name for this Custom App
func (r ApiCreateCustomAppRequest) Name(name string) ApiCreateCustomAppRequest {
	r.name = &name
	return r
}

// (Required) The S3 key from the &lt;code&gt;Upload Custom App&lt;/code&gt; endpont used to upload the custom app file.
func (r ApiCreateCustomAppRequest) FileKey(fileKey string) ApiCreateCustomAppRequest {
	r.fileKey = &fileKey
	return r
}

// (Required) Options are package, zip, image
func (r ApiCreateCustomAppRequest) InstallType(installType string) ApiCreateCustomAppRequest {
	r.installType = &installType
	return r
}

// (Required) Options are install_once, continuously_enforce, no_enforcement
func (r ApiCreateCustomAppRequest) InstallEnforcement(installEnforcement string) ApiCreateCustomAppRequest {
	r.installEnforcement = &installEnforcement
	return r
}

// (Optional, default&#x3D;false) Displays this app in Self Service
func (r ApiCreateCustomAppRequest) ShowInSelfService(showInSelfService string) ApiCreateCustomAppRequest {
	r.showInSelfService = &showInSelfService
	return r
}

// (Required for show_in_self_service&#x3D;true) Self Service Category (by ID) to display app in
func (r ApiCreateCustomAppRequest) SelfServiceCategoryId(selfServiceCategoryId string) ApiCreateCustomAppRequest {
	r.selfServiceCategoryId = &selfServiceCategoryId
	return r
}

// (Optional, default&#x3D;false) Adds recommended flag to app in Self Service
func (r ApiCreateCustomAppRequest) SelfServiceRecommended(selfServiceRecommended string) ApiCreateCustomAppRequest {
	r.selfServiceRecommended = &selfServiceRecommended
	return r
}

func (r ApiCreateCustomAppRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CreateCustomAppExecute(r)
}

/*
CreateCustomApp Create Custom App

<p>This request allows you to create a custom app in the Kandji library.</p>
<p>Must have already generated a <code>file_key</code> via <code>Create custom app</code> endpoint and uploaded the file to S3 using a request similar to the <code>Upload to S3</code> example.</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateCustomAppRequest
*/
func (a *CustomAppsAPIService) CreateCustomApp(ctx context.Context) ApiCreateCustomAppRequest {
	return ApiCreateCustomAppRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *CustomAppsAPIService) CreateCustomAppExecute(r ApiCreateCustomAppRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomAppsAPIService.CreateCustomApp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/library/custom-apps"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.name == nil {
		return localVarReturnValue, nil, reportError("name is required and must be specified")
	}
	if r.fileKey == nil {
		return localVarReturnValue, nil, reportError("fileKey is required and must be specified")
	}
	if r.installType == nil {
		return localVarReturnValue, nil, reportError("installType is required and must be specified")
	}
	if r.installEnforcement == nil {
		return localVarReturnValue, nil, reportError("installEnforcement is required and must be specified")
	}
	if r.showInSelfService == nil {
		return localVarReturnValue, nil, reportError("showInSelfService is required and must be specified")
	}
	if r.selfServiceCategoryId == nil {
		return localVarReturnValue, nil, reportError("selfServiceCategoryId is required and must be specified")
	}
	if r.selfServiceRecommended == nil {
		return localVarReturnValue, nil, reportError("selfServiceRecommended is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "name", r.name, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "file_key", r.fileKey, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "install_type", r.installType, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "install_enforcement", r.installEnforcement, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "show_in_self_service", r.showInSelfService, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "self_service_category_id", r.selfServiceCategoryId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "self_service_recommended", r.selfServiceRecommended, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCustomAppRequest struct {
	ctx context.Context
	ApiService CustomAppsAPI
	libraryItemId string
}

func (r ApiDeleteCustomAppRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteCustomAppExecute(r)
}

/*
DeleteCustomApp Delete Custom App

<p>NOTICE: This is permanent so be careful.</p>
<p>This endpoint sends a request to delete a specific custom app from the Kandji library.</p>
<h3 id=&quot;request-parameters&quot;>Request Parameters</h3>
<p><code>library_item_id</code> (path parameter): The unique identifier of the library item.</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param libraryItemId
 @return ApiDeleteCustomAppRequest
*/
func (a *CustomAppsAPIService) DeleteCustomApp(ctx context.Context, libraryItemId string) ApiDeleteCustomAppRequest {
	return ApiDeleteCustomAppRequest{
		ApiService: a,
		ctx: ctx,
		libraryItemId: libraryItemId,
	}
}

// Execute executes the request
func (a *CustomAppsAPIService) DeleteCustomAppExecute(r ApiDeleteCustomAppRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomAppsAPIService.DeleteCustomApp")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/library/custom-apps/{library_item_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"library_item_id"+"}", url.PathEscape(parameterValueToString(r.libraryItemId, "libraryItemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/html; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetCustomAppRequest struct {
	ctx context.Context
	ApiService CustomAppsAPI
	libraryItemId string
}

func (r ApiGetCustomAppRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetCustomAppExecute(r)
}

/*
GetCustomApp Get Custom App

<p>This endpoint retrieves details about a specific custom app from the Kandji library.</p>
<h3 id=&quot;request-parameters&quot;>Request Parameters</h3>
<p><code>library_item_id</code> (path parameter): The unique identifier of the library item.</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param libraryItemId
 @return ApiGetCustomAppRequest
*/
func (a *CustomAppsAPIService) GetCustomApp(ctx context.Context, libraryItemId string) ApiGetCustomAppRequest {
	return ApiGetCustomAppRequest{
		ApiService: a,
		ctx: ctx,
		libraryItemId: libraryItemId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *CustomAppsAPIService) GetCustomAppExecute(r ApiGetCustomAppRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomAppsAPIService.GetCustomApp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/library/custom-apps/{library_item_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"library_item_id"+"}", url.PathEscape(parameterValueToString(r.libraryItemId, "libraryItemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListCustomAppsRequest struct {
	ctx context.Context
	ApiService CustomAppsAPI
	page *string
}

// Optional page number. Used when results exceed pagination threshold. A hard upper &lt;code&gt;limit&lt;/code&gt; is set at 300 device records returned per request.
func (r ApiListCustomAppsRequest) Page(page string) ApiListCustomAppsRequest {
	r.page = &page
	return r
}

func (r ApiListCustomAppsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ListCustomAppsExecute(r)
}

/*
ListCustomApps List Custom Apps

This endpoint makes a request to retrieve a list of custom apps from the Kandji library.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListCustomAppsRequest
*/
func (a *CustomAppsAPIService) ListCustomApps(ctx context.Context) ApiListCustomAppsRequest {
	return ApiListCustomAppsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *CustomAppsAPIService) ListCustomAppsExecute(r ApiListCustomAppsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomAppsAPIService.ListCustomApps")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/library/custom-apps"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateCustomAppRequest struct {
	ctx context.Context
	ApiService CustomAppsAPI
	libraryItemId string
	name *string
	active *string
}

// Renaming a Custom App
func (r ApiUpdateCustomAppRequest) Name(name string) ApiUpdateCustomAppRequest {
	r.name = &name
	return r
}

// (Optional, default&#x3D;true) Whether this Custom App is active and installable
func (r ApiUpdateCustomAppRequest) Active(active string) ApiUpdateCustomAppRequest {
	r.active = &active
	return r
}

func (r ApiUpdateCustomAppRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.UpdateCustomAppExecute(r)
}

/*
UpdateCustomApp Update Custom App

<p>This request allows you to update a custom app in the Kandji library.</p>
<p>Must have already generated a <code>file_key</code> via <code>Create custom app</code> endpoint and uploaded the file to S3 using a request similar to the <code>Upload to S3</code> example.</p>
<h3 id=&quot;request-parameters&quot;>Request Parameters</h3>
<p><code>library_item_id</code> (path parameter): The unique identifier of the library item.</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param libraryItemId
 @return ApiUpdateCustomAppRequest
*/
func (a *CustomAppsAPIService) UpdateCustomApp(ctx context.Context, libraryItemId string) ApiUpdateCustomAppRequest {
	return ApiUpdateCustomAppRequest{
		ApiService: a,
		ctx: ctx,
		libraryItemId: libraryItemId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *CustomAppsAPIService) UpdateCustomAppExecute(r ApiUpdateCustomAppRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomAppsAPIService.UpdateCustomApp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/library/custom-apps/{library_item_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"library_item_id"+"}", url.PathEscape(parameterValueToString(r.libraryItemId, "libraryItemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.name == nil {
		return localVarReturnValue, nil, reportError("name is required and must be specified")
	}
	if r.active == nil {
		return localVarReturnValue, nil, reportError("active is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "name", r.name, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "active", r.active, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUploadCustomAppRequest struct {
	ctx context.Context
	ApiService CustomAppsAPI
	body *string
}

func (r ApiUploadCustomAppRequest) Body(body string) ApiUploadCustomAppRequest {
	r.body = &body
	return r
}

func (r ApiUploadCustomAppRequest) Execute() (*http.Response, error) {
	return r.ApiService.UploadCustomAppExecute(r)
}

/*
UploadCustomApp Upload Custom App

<p>This request retrieves the S3 upload details need for uploading the app to Amazon S3.</p>
<p>Creates a pre-signed <code>post_url</code> to upload a new Custom App to S3.</p>
<p>The provided <code>name</code> will be used to calculate a unique <code>file_key</code> in S3.</p>
<p>A separate request will have to be made to the <code>Upload to S3</code> endpoint to upload the file to S3 directly using the <code>post_url</code> and <code>post_data</code> from the <code>Upload Custom App</code> response.</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUploadCustomAppRequest
*/
func (a *CustomAppsAPIService) UploadCustomApp(ctx context.Context) ApiUploadCustomAppRequest {
	return ApiUploadCustomAppRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *CustomAppsAPIService) UploadCustomAppExecute(r ApiUploadCustomAppRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomAppsAPIService.UploadCustomApp")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/library/custom-apps/upload"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
