/*
Kandji API

<html><head></head><body><h1 id=&quot;welcome-to-the-kandji-api-documentation&quot;>Welcome to the Kandji API Documentation</h1> <p>You can find your API URL in Settings &gt; Access. The API URL will follow the below formats.</p> <ul> <li><p>US - <code>https://SubDomain.api.kandji.io</code></p> </li> <li><p>EU - <code>https://SubDomain.api.eu.kandji.io</code></p> </li> </ul> <p>For information on how to obtain an API token, please refer to the following support article.</p> <p><a href=&quot;https://support.kandji.io/api&quot;>https://support.kandji.io/api</a></p> <h4 id=&quot;rate-limit&quot;>Rate Limit</h4> <p>The Kandji API currently has an API rate limit of 10,000 requests per hour per customer.</p> <h4 id=&quot;request-methods&quot;>Request Methods</h4> <p>HTTP request methods supported by the Kandji API.</p> <div class=&quot;click-to-expand-wrapper is-table-wrapper&quot;><table> <thead> <tr> <th>Method</th> <th>Definition</th> </tr> </thead> <tbody> <tr> <td>GET</td> <td>The <code>GET</code> method requests a representation of the specified resource.</td> </tr> <tr> <td>POST</td> <td>The <code>POST</code> method submits an entity to the specified resource.</td> </tr> <tr> <td>PATCH</td> <td>The <code>PATCH</code> method applies partial modifications to a resource.</td> </tr> <tr> <td>DELETE</td> <td>The <code>DELETE</code> method deletes the specified resource.</td> </tr> </tbody> </table> </div><h4 id=&quot;response-codes&quot;>Response codes</h4> <p>Not all response codes apply to every endpoint.</p> <div class=&quot;click-to-expand-wrapper is-table-wrapper&quot;><table> <thead> <tr> <th>Code</th> <th>Response</th> </tr> </thead> <tbody> <tr> <td>200</td> <td>OK</td> </tr> <tr> <td>201</td> <td>Created</td> </tr> <tr> <td>204</td> <td>No content</td> </tr> <tr> <td></td> <td>Typical response when sending the DELETE method.</td> </tr> <tr> <td>400</td> <td>Bad Request</td> </tr> <tr> <td></td> <td>&quot;Command already running&quot; - The command may already be running in a <em>Pending</em> state waiting on the device.</td> </tr> <tr> <td></td> <td>&quot;Command is not allowed for current device&quot; - The command may not be compatible with the target device.</td> </tr> <tr> <td></td> <td>&quot;JSON parse error - Expecting ',' delimiter: line 3 column 2 (char 65)&quot;</td> </tr> <tr> <td>401</td> <td>Unauthorized</td> </tr> <tr> <td></td> <td>This error can occur if the token is incorrect, was revoked, or the token has expired.</td> </tr> <tr> <td>403</td> <td>Forbidden</td> </tr> <tr> <td></td> <td>The request was understood but cannot be authorized.</td> </tr> <tr> <td>404</td> <td>Not found</td> </tr> <tr> <td></td> <td>Unable to locate the resource in the Kandji tenant.</td> </tr> <tr> <td>415</td> <td>Unsupported Media Type</td> </tr> <tr> <td></td> <td>The request contains a media type which the server or resource does not support.</td> </tr> <tr> <td>500</td> <td>Internal server error</td> </tr> <tr> <td>503</td> <td>Service unavailable</td> </tr> <tr> <td></td> <td>This error can occur if a file upload is still being processed via the custom apps API.</td> </tr> </tbody> </table> </div><h4 id=&quot;data-structure&quot;>Data structure</h4> <p>The API returns all structured responses in JSON schema format.</p> <h4 id=&quot;examples&quot;>Examples</h4> <p>Code examples using the API can be found in the Kandji support <a href=&quot;https://github.com/kandji-inc/support/tree/main/api-tools&quot;>GitHub</a>.</p> </body></html>

API version: 1.0.0
Contact: mitchelsblake@gmail.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package kandji_sdk

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// BlueprintsAPIService BlueprintsAPI service
type BlueprintsAPIService service

type ApiBlueprintsAssignLibraryItemRequest struct {
	ctx context.Context
	ApiService *BlueprintsAPIService
	blueprintId string
	body *string
}

func (r ApiBlueprintsAssignLibraryItemRequest) Body(body string) ApiBlueprintsAssignLibraryItemRequest {
	r.body = &body
	return r
}

func (r ApiBlueprintsAssignLibraryItemRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.BlueprintsAssignLibraryItemExecute(r)
}

/*
BlueprintsAssignLibraryItem Assign Library Item

<p>This endpoint allows assigning a library item to a specific blueprint (classic and maps). The response will include a list of library item IDs assigned to the blueprint.</p>
<h3 id=&quot;request-parameters&quot;>Request Parameters</h3>
<p><code>blueprint_id</code> (path parameter): The unique identifier of the blueprint.</p>
<h3 id=&quot;request-body&quot;>Request Body</h3>
<ul>
<li><p><code>library_item_id</code> (string, required)</p>
</li>
<li><p><code>assignment_node_id</code> (string, required for maps)</p>
<ul>
<li>Note: To find the assignment_node_id, view the map in a browser. Then, on your keyboard, press and hold the Option ‚å• key. Each node ID remains fixed for the lifespan of the node on the map.</li>
</ul>
</li>
</ul>
<h3 id=&quot;error-responses&quot;>Error responses</h3>
<div class=&quot;click-to-expand-wrapper is-table-wrapper&quot;><table>
<thead>
<tr>
<th><strong>Code</strong></th>
<th><strong>Body</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>400 - Bad Request</td>
<td>Bad Request</td>
</tr>
<tr>
<td></td>
<td>&quot;Library Item already exists on Blueprint&quot;</td>
</tr>
<tr>
<td></td>
<td>&quot;Library Item already exists in Assignment Node&quot;</td>
</tr>
<tr>
<td></td>
<td>&quot;assignment_node_id cannot be provided for Classic Blueprint&quot;</td>
</tr>
<tr>
<td></td>
<td>&quot;Must provide assignment_node_id for Assignment Map Blueprint&quot;</td>
</tr>
</tbody>
</table>
</div>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blueprintId
 @return ApiBlueprintsAssignLibraryItemRequest
*/
func (a *BlueprintsAPIService) BlueprintsAssignLibraryItem(ctx context.Context, blueprintId string) ApiBlueprintsAssignLibraryItemRequest {
	return ApiBlueprintsAssignLibraryItemRequest{
		ApiService: a,
		ctx: ctx,
		blueprintId: blueprintId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *BlueprintsAPIService) BlueprintsAssignLibraryItemExecute(r ApiBlueprintsAssignLibraryItemRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlueprintsAPIService.BlueprintsAssignLibraryItem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/blueprints/{blueprint_id}/assign-library-item"
	localVarPath = strings.Replace(localVarPath, "{"+"blueprint_id"+"}", url.PathEscape(parameterValueToString(r.blueprintId, "blueprintId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBlueprintsCreateBlueprintRequest struct {
	ctx context.Context
	ApiService *BlueprintsAPIService
	name *string
	enrollmentCodeIsActive *string
	enrollmentCodeCode *string
	sourceType *string
	sourceId *string
	type_ *string
}

// (required) Set the name of the Blueprint. The name provided must be unique.
func (r ApiBlueprintsCreateBlueprintRequest) Name(name string) ApiBlueprintsCreateBlueprintRequest {
	r.name = &name
	return r
}

// (required) Enable or Disable the Blueprint for manual device enrollment from the enrollment portal
func (r ApiBlueprintsCreateBlueprintRequest) EnrollmentCodeIsActive(enrollmentCodeIsActive string) ApiBlueprintsCreateBlueprintRequest {
	r.enrollmentCodeIsActive = &enrollmentCodeIsActive
	return r
}

// Optionally, set the enrollment code of the Blueprint. This key is not required. If an enrollment code is not supplied in the payload body, it will be randomly generated. The enrollment code will be returned in the response and visible in the Web app.
func (r ApiBlueprintsCreateBlueprintRequest) EnrollmentCodeCode(enrollmentCodeCode string) ApiBlueprintsCreateBlueprintRequest {
	r.enrollmentCodeCode = &enrollmentCodeCode
	return r
}

// Set the source to create the blueprint from. Possible options: &lt;code&gt;template&lt;/code&gt; and &lt;code&gt;blueprint&lt;/code&gt;.
func (r ApiBlueprintsCreateBlueprintRequest) SourceType(sourceType string) ApiBlueprintsCreateBlueprintRequest {
	r.sourceType = &sourceType
	return r
}

// Set either the source template ID, or the source Blueprint ID to clone an existing template or blueprint.
func (r ApiBlueprintsCreateBlueprintRequest) SourceId(sourceId string) ApiBlueprintsCreateBlueprintRequest {
	r.sourceId = &sourceId
	return r
}

// Choose the type of blueprint to create. Options: &lt;code&gt;classic&lt;/code&gt; or &lt;code&gt;map&lt;/code&gt;
func (r ApiBlueprintsCreateBlueprintRequest) Type_(type_ string) ApiBlueprintsCreateBlueprintRequest {
	r.type_ = &type_
	return r
}

func (r ApiBlueprintsCreateBlueprintRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.BlueprintsCreateBlueprintExecute(r)
}

/*
BlueprintsCreateBlueprint Create Blueprint

<p>This request creates a new empty Blueprint or a new Blueprint from a template. The keys <code>name</code> and <code>enrollment_code</code> <code>is_active</code> are required, and the blueprint name key must be unique from the existing blueprint names in the Kandji tenant.</p>
<p>optionally, <code>type: map</code> can be used when creating a new Assignment Map blueprint.</p>
<p>Note: If cloning an existing blueprint,`type` value and the type of sourced (`source.id`) blueprint must match and `source.type` value must be set to `blueprint`.</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBlueprintsCreateBlueprintRequest
*/
func (a *BlueprintsAPIService) BlueprintsCreateBlueprint(ctx context.Context) ApiBlueprintsCreateBlueprintRequest {
	return ApiBlueprintsCreateBlueprintRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *BlueprintsAPIService) BlueprintsCreateBlueprintExecute(r ApiBlueprintsCreateBlueprintRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlueprintsAPIService.BlueprintsCreateBlueprint")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/blueprints"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.name == nil {
		return localVarReturnValue, nil, reportError("name is required and must be specified")
	}
	if r.enrollmentCodeIsActive == nil {
		return localVarReturnValue, nil, reportError("enrollmentCodeIsActive is required and must be specified")
	}
	if r.enrollmentCodeCode == nil {
		return localVarReturnValue, nil, reportError("enrollmentCodeCode is required and must be specified")
	}
	if r.sourceType == nil {
		return localVarReturnValue, nil, reportError("sourceType is required and must be specified")
	}
	if r.sourceId == nil {
		return localVarReturnValue, nil, reportError("sourceId is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "name", r.name, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "enrollment_code.is_active", r.enrollmentCodeIsActive, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "enrollment_code.code", r.enrollmentCodeCode, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "source.type", r.sourceType, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "source.id", r.sourceId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "type", r.type_, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBlueprintsDeleteBlueprintRequest struct {
	ctx context.Context
	ApiService *BlueprintsAPIService
	blueprintId string
}

func (r ApiBlueprintsDeleteBlueprintRequest) Execute() (*http.Response, error) {
	return r.ApiService.BlueprintsDeleteBlueprintExecute(r)
}

/*
BlueprintsDeleteBlueprint Delete Blueprint

<h1 id=&quot;warning&quot;><strong>WARNING!</strong></h1>
<p>This is a HIGHLY destructive action.</p>
<p>Deleting a Blueprint will un-manage ALL devices assigned to the Blueprint.</p>
<h3 id=&quot;request-parameters&quot;>Request Parameters</h3>
<p><code>blueprint_id</code> (path parameter): The unique identifier of the blueprint.</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blueprintId
 @return ApiBlueprintsDeleteBlueprintRequest
*/
func (a *BlueprintsAPIService) BlueprintsDeleteBlueprint(ctx context.Context, blueprintId string) ApiBlueprintsDeleteBlueprintRequest {
	return ApiBlueprintsDeleteBlueprintRequest{
		ApiService: a,
		ctx: ctx,
		blueprintId: blueprintId,
	}
}

// Execute executes the request
func (a *BlueprintsAPIService) BlueprintsDeleteBlueprintExecute(r ApiBlueprintsDeleteBlueprintRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlueprintsAPIService.BlueprintsDeleteBlueprint")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/blueprints/{blueprint_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"blueprint_id"+"}", url.PathEscape(parameterValueToString(r.blueprintId, "blueprintId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiBlueprintsGetBlueprintRequest struct {
	ctx context.Context
	ApiService *BlueprintsAPIService
	blueprintId string
}

func (r ApiBlueprintsGetBlueprintRequest) Execute() (*http.Response, error) {
	return r.ApiService.BlueprintsGetBlueprintExecute(r)
}

/*
BlueprintsGetBlueprint Get Blueprint

<p>This request returns information about a specific blueprint based on blueprint ID.</p>
<h3 id=&quot;request-parameters&quot;>Request Parameters</h3>
<p><code>blueprint_id</code> (path parameter): The unique identifier of the blueprint.</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blueprintId
 @return ApiBlueprintsGetBlueprintRequest
*/
func (a *BlueprintsAPIService) BlueprintsGetBlueprint(ctx context.Context, blueprintId string) ApiBlueprintsGetBlueprintRequest {
	return ApiBlueprintsGetBlueprintRequest{
		ApiService: a,
		ctx: ctx,
		blueprintId: blueprintId,
	}
}

// Execute executes the request
func (a *BlueprintsAPIService) BlueprintsGetBlueprintExecute(r ApiBlueprintsGetBlueprintRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlueprintsAPIService.BlueprintsGetBlueprint")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/blueprints/{blueprint_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"blueprint_id"+"}", url.PathEscape(parameterValueToString(r.blueprintId, "blueprintId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiBlueprintsGetBlueprintTemplatesRequest struct {
	ctx context.Context
	ApiService *BlueprintsAPIService
	limit *string
	offset *string
}

// Number of results to return per page.
func (r ApiBlueprintsGetBlueprintTemplatesRequest) Limit(limit string) ApiBlueprintsGetBlueprintTemplatesRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiBlueprintsGetBlueprintTemplatesRequest) Offset(offset string) ApiBlueprintsGetBlueprintTemplatesRequest {
	r.offset = &offset
	return r
}

func (r ApiBlueprintsGetBlueprintTemplatesRequest) Execute() (*http.Response, error) {
	return r.ApiService.BlueprintsGetBlueprintTemplatesExecute(r)
}

/*
BlueprintsGetBlueprintTemplates Get Blueprint Templates

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBlueprintsGetBlueprintTemplatesRequest
*/
func (a *BlueprintsAPIService) BlueprintsGetBlueprintTemplates(ctx context.Context) ApiBlueprintsGetBlueprintTemplatesRequest {
	return ApiBlueprintsGetBlueprintTemplatesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *BlueprintsAPIService) BlueprintsGetBlueprintTemplatesExecute(r ApiBlueprintsGetBlueprintTemplatesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlueprintsAPIService.BlueprintsGetBlueprintTemplates")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/blueprints/templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiBlueprintsGetManualEnrollmentProfileRequest struct {
	ctx context.Context
	ApiService *BlueprintsAPIService
	blueprintId string
	sso *string
}

// Use the &lt;code&gt;sso&lt;/code&gt; query parameter, set to &lt;code&gt;true&lt;/code&gt;, to return a URL instead of the manual enrollment profile. This parameter should only be used for blueprints in which &amp;quot;Require Authentication&amp;quot; is configured for Manual Enrollment. The returned URL must be used to authenticate via SSO to receive an enrollment profile.
func (r ApiBlueprintsGetManualEnrollmentProfileRequest) Sso(sso string) ApiBlueprintsGetManualEnrollmentProfileRequest {
	r.sso = &sso
	return r
}

func (r ApiBlueprintsGetManualEnrollmentProfileRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.BlueprintsGetManualEnrollmentProfileExecute(r)
}

/*
BlueprintsGetManualEnrollmentProfile Get Manual Enrollment Profile

<p>This request returns the manual enrollment profile (.mobileconfig file) for a specified Blueprint.</p>
<p>This request will return the enrollment profile even if &quot;Require Authentication&quot; is configured for the Blueprint in Manual Enrollment.</p>
<p>The enrollment profile will be returned in raw form with response headers:</p>
<ul>
<li><p><code>Content-Type</code> = <code>application/x-apple-aspen-config</code></p>
</li>
<li><p><code>Content-Disposition</code> = <code>attachment;filename=kandji-enroll.mobileconfig</code></p>
</li>
</ul>
<p>An optional query parameter <code>sso=true</code> can be used to return a URL for SSO authentication instead. If this query parameter is used for a Blueprint that does not require authentication, then the enrollment profile will be returned.</p>
<h3 id=&quot;request-parameters&quot;>Request Parameters</h3>
<p><code>blueprint_id</code> (path parameter): The unique identifier of the blueprint.</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blueprintId
 @return ApiBlueprintsGetManualEnrollmentProfileRequest
*/
func (a *BlueprintsAPIService) BlueprintsGetManualEnrollmentProfile(ctx context.Context, blueprintId string) ApiBlueprintsGetManualEnrollmentProfileRequest {
	return ApiBlueprintsGetManualEnrollmentProfileRequest{
		ApiService: a,
		ctx: ctx,
		blueprintId: blueprintId,
	}
}

// Execute executes the request
//  @return string
func (a *BlueprintsAPIService) BlueprintsGetManualEnrollmentProfileExecute(r ApiBlueprintsGetManualEnrollmentProfileRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlueprintsAPIService.BlueprintsGetManualEnrollmentProfile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/blueprints/{blueprint_id}/ota-enrollment-profile"
	localVarPath = strings.Replace(localVarPath, "{"+"blueprint_id"+"}", url.PathEscape(parameterValueToString(r.blueprintId, "blueprintId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.sso != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sso", r.sso, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-apple-aspen-config"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBlueprintsListBlueprintsRequest struct {
	ctx context.Context
	ApiService *BlueprintsAPIService
	id *string
	idIn *string
	name *string
	limit *string
	offset *string
}

// Look up a specific Blueprint by its ID
func (r ApiBlueprintsListBlueprintsRequest) Id(id string) ApiBlueprintsListBlueprintsRequest {
	r.id = &id
	return r
}

// Specify a list of Blueprint IDs to limit the results to.  Multiple values may be separated by commas. There is a double underscore (&lt;code&gt;__&lt;/code&gt;) between id and in
func (r ApiBlueprintsListBlueprintsRequest) IdIn(idIn string) ApiBlueprintsListBlueprintsRequest {
	r.idIn = &idIn
	return r
}

// Return Blueprint names &amp;quot;containing&amp;quot; the specified search string.
func (r ApiBlueprintsListBlueprintsRequest) Name(name string) ApiBlueprintsListBlueprintsRequest {
	r.name = &name
	return r
}

// Number of results to return per page.
func (r ApiBlueprintsListBlueprintsRequest) Limit(limit string) ApiBlueprintsListBlueprintsRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiBlueprintsListBlueprintsRequest) Offset(offset string) ApiBlueprintsListBlueprintsRequest {
	r.offset = &offset
	return r
}

func (r ApiBlueprintsListBlueprintsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.BlueprintsListBlueprintsExecute(r)
}

/*
BlueprintsListBlueprints List Blueprints

This request returns a list of a blueprint records in the Kandji tenant. Optional query parameters can be specified to filter the results.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBlueprintsListBlueprintsRequest
*/
func (a *BlueprintsAPIService) BlueprintsListBlueprints(ctx context.Context) ApiBlueprintsListBlueprintsRequest {
	return ApiBlueprintsListBlueprintsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *BlueprintsAPIService) BlueprintsListBlueprintsExecute(r ApiBlueprintsListBlueprintsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlueprintsAPIService.BlueprintsListBlueprints")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/blueprints"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	if r.idIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id__in", r.idIn, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBlueprintsListLibraryItemsRequest struct {
	ctx context.Context
	ApiService *BlueprintsAPIService
	blueprintId string
}

func (r ApiBlueprintsListLibraryItemsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.BlueprintsListLibraryItemsExecute(r)
}

/*
BlueprintsListLibraryItems List Library Items

<p>This API endpoint retrieves a list of library items associated with a specific blueprint. (classic and maps). Requires that the blueprint ID is passed as a path parameter in the URL.</p>
<h3 id=&quot;request-parameters&quot;>Request Parameters</h3>
<p><code>blueprint_id</code> (path parameter): The unique identifier of the blueprint.</p>
<h3 id=&quot;response-fields&quot;>Response fields</h3>
<ul>
<li><p><code>count</code> (int): The total count of library items.</p>
</li>
<li><p><code>next</code> (str): The URL for the next page of results, if available. If not available will value will be <code>null</code>.</p>
</li>
<li><p><code>previous</code> (str): The URL for the previous page of results, if available. If not available will value will be <code>null</code>.</p>
</li>
<li><p><code>results</code> (object): An array containing objects with the following fields:</p>
<ul>
<li><p><code>id</code> (str): The ID of the library item.</p>
</li>
<li><p><code>name</code> (str): The name of the library item.</p>
</li>
</ul>
</li>
</ul>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blueprintId
 @return ApiBlueprintsListLibraryItemsRequest
*/
func (a *BlueprintsAPIService) BlueprintsListLibraryItems(ctx context.Context, blueprintId string) ApiBlueprintsListLibraryItemsRequest {
	return ApiBlueprintsListLibraryItemsRequest{
		ApiService: a,
		ctx: ctx,
		blueprintId: blueprintId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *BlueprintsAPIService) BlueprintsListLibraryItemsExecute(r ApiBlueprintsListLibraryItemsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlueprintsAPIService.BlueprintsListLibraryItems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/blueprints/{blueprint_id}/list-library-items"
	localVarPath = strings.Replace(localVarPath, "{"+"blueprint_id"+"}", url.PathEscape(parameterValueToString(r.blueprintId, "blueprintId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBlueprintsRemoveLibraryItemRequest struct {
	ctx context.Context
	ApiService *BlueprintsAPIService
	blueprintId string
	body *string
}

func (r ApiBlueprintsRemoveLibraryItemRequest) Body(body string) ApiBlueprintsRemoveLibraryItemRequest {
	r.body = &body
	return r
}

func (r ApiBlueprintsRemoveLibraryItemRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.BlueprintsRemoveLibraryItemExecute(r)
}

/*
BlueprintsRemoveLibraryItem Remove Library Item

<p>This endpoint allows removing a library item from a specific blueprint (classic and maps). The response will include a list of library item IDs assigned to the blueprint.</p>
<h3 id=&quot;request-parameters&quot;>Request Parameters</h3>
<p><code>blueprint_id</code> (path parameter): The unique identifier of the blueprint.</p>
<h3 id=&quot;request-body&quot;>Request Body</h3>
<ul>
<li><p><code>library_item_id</code> (string, required)</p>
</li>
<li><p><code>assignment_node_id</code> (string, required for maps)</p>
</li>
</ul>
<h3 id=&quot;error-responses&quot;>Error responses</h3>
<div class=&quot;click-to-expand-wrapper is-table-wrapper&quot;><table>
<thead>
<tr>
<th><strong>Code</strong></th>
<th><strong>Body</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>400 - Bad Request</td>
<td>Bad Request</td>
</tr>
<tr>
<td></td>
<td>&quot;assignment_node_id cannot be provided for Classic Blueprint&quot;</td>
</tr>
<tr>
<td></td>
<td>&quot;Must provide assignment_node_id for Assignment Map Blueprint&quot;</td>
</tr>
<tr>
<td></td>
<td>&quot;Library Item does not exist on Blueprint&quot;</td>
</tr>
<tr>
<td></td>
<td>&quot;Library Item does not exist in Assignment Node&quot;</td>
</tr>
</tbody>
</table>
</div>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blueprintId
 @return ApiBlueprintsRemoveLibraryItemRequest
*/
func (a *BlueprintsAPIService) BlueprintsRemoveLibraryItem(ctx context.Context, blueprintId string) ApiBlueprintsRemoveLibraryItemRequest {
	return ApiBlueprintsRemoveLibraryItemRequest{
		ApiService: a,
		ctx: ctx,
		blueprintId: blueprintId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *BlueprintsAPIService) BlueprintsRemoveLibraryItemExecute(r ApiBlueprintsRemoveLibraryItemRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlueprintsAPIService.BlueprintsRemoveLibraryItem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/blueprints/{blueprint_id}/remove-library-item"
	localVarPath = strings.Replace(localVarPath, "{"+"blueprint_id"+"}", url.PathEscape(parameterValueToString(r.blueprintId, "blueprintId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBlueprintsUpdateBlueprintRequest struct {
	ctx context.Context
	ApiService *BlueprintsAPIService
	blueprintId string
	name *string
	description *string
	enrollmentCodeCode *string
	enrollmentCodeIsActive *string
}

// Update the name of the Blueprint
func (r ApiBlueprintsUpdateBlueprintRequest) Name(name string) ApiBlueprintsUpdateBlueprintRequest {
	r.name = &name
	return r
}

// Update the description of the Blueprint 
func (r ApiBlueprintsUpdateBlueprintRequest) Description(description string) ApiBlueprintsUpdateBlueprintRequest {
	r.description = &description
	return r
}

// Update the enrollment code of the Blueprint 
func (r ApiBlueprintsUpdateBlueprintRequest) EnrollmentCodeCode(enrollmentCodeCode string) ApiBlueprintsUpdateBlueprintRequest {
	r.enrollmentCodeCode = &enrollmentCodeCode
	return r
}

// Disable the Blueprint for manual device enrollment from the enrollment portal.
func (r ApiBlueprintsUpdateBlueprintRequest) EnrollmentCodeIsActive(enrollmentCodeIsActive string) ApiBlueprintsUpdateBlueprintRequest {
	r.enrollmentCodeIsActive = &enrollmentCodeIsActive
	return r
}

func (r ApiBlueprintsUpdateBlueprintRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.BlueprintsUpdateBlueprintExecute(r)
}

/*
BlueprintsUpdateBlueprint Update Blueprint

<p>This requests allows updating of the name, icon, icon color, description, enrollment code, and active status on an existing blueprint.</p>
<h3 id=&quot;request-parameters&quot;>Request Parameters</h3>
<p><code>blueprint_id</code> (path parameter): The unique identifier of the blueprint.</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blueprintId
 @return ApiBlueprintsUpdateBlueprintRequest
*/
func (a *BlueprintsAPIService) BlueprintsUpdateBlueprint(ctx context.Context, blueprintId string) ApiBlueprintsUpdateBlueprintRequest {
	return ApiBlueprintsUpdateBlueprintRequest{
		ApiService: a,
		ctx: ctx,
		blueprintId: blueprintId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *BlueprintsAPIService) BlueprintsUpdateBlueprintExecute(r ApiBlueprintsUpdateBlueprintRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlueprintsAPIService.BlueprintsUpdateBlueprint")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/blueprints/{blueprint_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"blueprint_id"+"}", url.PathEscape(parameterValueToString(r.blueprintId, "blueprintId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.name == nil {
		return localVarReturnValue, nil, reportError("name is required and must be specified")
	}
	if r.description == nil {
		return localVarReturnValue, nil, reportError("description is required and must be specified")
	}
	if r.enrollmentCodeCode == nil {
		return localVarReturnValue, nil, reportError("enrollmentCodeCode is required and must be specified")
	}
	if r.enrollmentCodeIsActive == nil {
		return localVarReturnValue, nil, reportError("enrollmentCodeIsActive is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "name", r.name, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "description", r.description, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "enrollment_code.code", r.enrollmentCodeCode, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "enrollment_code.is_active", r.enrollmentCodeIsActive, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
