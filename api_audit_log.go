/*
Iru Endpoint Management API

<html><head></head><body><h1 id=&quot;welcome-to-the-iru-endpoint-management-api-documentation&quot;>Welcome to the Iru Endpoint Management API Documentation</h1> <p><strong>Note:</strong> Kandji is now Iru, but many URLs and notes within this documentation will continue to reference Kandji for some time.</p> <p>You can find your API URL in Settings &gt; Access. The API URL will follow the below formats.</p> <ul> <li><p>US - <code>https://SubDomain.api.kandji.io</code></p> </li> <li><p>EU - <code>https://SubDomain.api.eu.kandji.io</code></p> </li> </ul> <p>For information on how to obtain an API token, please refer to the following support article.</p> <p><a href=&quot;https://support.kandji.io/api&quot;>https://support.kandji.io/api</a></p> <h4 id=&quot;rate-limit&quot;>Rate Limit</h4> <p>The Iru Endpoint Management API currently has an API rate limit of 10,000 requests per hour per customer.</p> <h4 id=&quot;request-methods&quot;>Request Methods</h4> <p>HTTP request methods supported by the API.</p> <div class=&quot;click-to-expand-wrapper is-table-wrapper&quot;><table> <thead> <tr> <th>Method</th> <th>Definition</th> </tr> </thead> <tbody> <tr> <td>GET</td> <td>The <code>GET</code> method requests a representation of the specified resource.</td> </tr> <tr> <td>POST</td> <td>The <code>POST</code> method submits an entity to the specified resource.</td> </tr> <tr> <td>PATCH</td> <td>The <code>PATCH</code> method applies partial modifications to a resource.</td> </tr> <tr> <td>DELETE</td> <td>The <code>DELETE</code> method deletes the specified resource.</td> </tr> </tbody> </table> </div><h4 id=&quot;response-codes&quot;>Response codes</h4> <p>Not all response codes apply to every endpoint.</p> <div class=&quot;click-to-expand-wrapper is-table-wrapper&quot;><table> <thead> <tr> <th>Code</th> <th>Response</th> </tr> </thead> <tbody> <tr> <td>200</td> <td>OK</td> </tr> <tr> <td>201</td> <td>Created</td> </tr> <tr> <td>204</td> <td>No content</td> </tr> <tr> <td></td> <td>Typical response when sending the DELETE method.</td> </tr> <tr> <td>400</td> <td>Bad Request</td> </tr> <tr> <td></td> <td>&quot;Command already running&quot; - The command may already be running in a <em>Pending</em> state waiting on the device.</td> </tr> <tr> <td></td> <td>&quot;Command is not allowed for current device&quot; - The command may not be compatible with the target device.</td> </tr> <tr> <td></td> <td>&quot;JSON parse error - Expecting ',' delimiter: line 3 column 2 (char 65)&quot;</td> </tr> <tr> <td>401</td> <td>Unauthorized</td> </tr> <tr> <td></td> <td>This error can occur if the token is incorrect, was revoked, or the token has expired.</td> </tr> <tr> <td>403</td> <td>Forbidden</td> </tr> <tr> <td></td> <td>The request was understood but cannot be authorized.</td> </tr> <tr> <td>404</td> <td>Not found</td> </tr> <tr> <td></td> <td>Unable to locate the resource in the Iru tenant.</td> </tr> <tr> <td>415</td> <td>Unsupported Media Type</td> </tr> <tr> <td></td> <td>The request contains a media type which the server or resource does not support.</td> </tr> <tr> <td>500</td> <td>Internal server error</td> </tr> <tr> <td>503</td> <td>Service unavailable</td> </tr> <tr> <td></td> <td>This error can occur if a file upload is still being processed via the custom apps API.</td> </tr> </tbody> </table> </div><h4 id=&quot;data-structure&quot;>Data structure</h4> <p>The API returns all structured responses in JSON schema format.</p> <h4 id=&quot;examples&quot;>Examples</h4> <p>Code examples using the API can be found in the Iru Endpoint Management support <a href=&quot;https://github.com/kandji-inc/support/tree/main/api-tools&quot;>GitHub</a>.</p> </body></html>

API version: 1.0.0
Contact: mitchelsblake@gmail.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package kandji

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


type AuditLogAPI interface {

	/*
	ListAuditEvents List audit events

	<p>List audit log events from the Activity module.</p>
<p>Returns events related to</p>
<ul>
<li><p>Blueprint and Library Item creation, updates, and deletions (Create, Update, Delete)</p>
</li>
<li><p>Access to sensitive data (such as FileVault keys and recovery keys)</p>
</li>
<li><p>Device lifecycle events (enrollment, deletion, MDM removal, blueprint changes)</p>
</li>
<li><p>User directory events (including directory user deletions)</p>
</li>
<li><p>Administrative actions (tenant owner updates, API token management (Create, Update, Delete))</p>
</li>
<li><p>Admin user management activities</p>
</li>
<li><p>Vulnerability management events for detections and remediations (for customers with this feature)</p>
</li>
<li><p>Endpoint Detection and Response events for detections, remediations, and admin actions (for customers with this feature)</p>
</li>
</ul>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListAuditEventsRequest
	*/
	ListAuditEvents(ctx context.Context) ApiListAuditEventsRequest

	// ListAuditEventsExecute executes the request
	//  @return AuditLogListAuditEvents200Response
	ListAuditEventsExecute(r ApiListAuditEventsRequest) (*AuditLogListAuditEvents200Response, *http.Response, error)
}

// AuditLogAPIService AuditLogAPI service
type AuditLogAPIService service

type ApiListAuditEventsRequest struct {
	ctx context.Context
	ApiService AuditLogAPI
	limit *string
	sortBy *string
	startDate *string
	endDate *string
	cursor *string
}

// A max upper &lt;code&gt;limit&lt;/code&gt; is set at 500 records returned per request. Pagination should be used using the cursor in the &lt;code&gt;next&lt;/code&gt; key to request more results. Additionally, parameter queries can be added to a request to filter the results.
func (r ApiListAuditEventsRequest) Limit(limit string) ApiListAuditEventsRequest {
	r.limit = &limit
	return r
}

// Sort results by &lt;code&gt;occurred_at&lt;/code&gt;, &lt;code&gt;id&lt;/code&gt; either ascending (default behavior) or descending(-) order.
func (r ApiListAuditEventsRequest) SortBy(sortBy string) ApiListAuditEventsRequest {
	r.sortBy = &sortBy
	return r
}

// Filter by start date in datetime or year-month-day (2024-11-26) formats
func (r ApiListAuditEventsRequest) StartDate(startDate string) ApiListAuditEventsRequest {
	r.startDate = &startDate
	return r
}

// Filter by start date in datetime or year-month-day (2024-12-06) formats
func (r ApiListAuditEventsRequest) EndDate(endDate string) ApiListAuditEventsRequest {
	r.endDate = &endDate
	return r
}

// You can pass the next cursor as a parameter or use the URL in the next key to get the next page of results or to start from where you left off last.
func (r ApiListAuditEventsRequest) Cursor(cursor string) ApiListAuditEventsRequest {
	r.cursor = &cursor
	return r
}

func (r ApiListAuditEventsRequest) Execute() (*AuditLogListAuditEvents200Response, *http.Response, error) {
	return r.ApiService.ListAuditEventsExecute(r)
}

/*
ListAuditEvents List audit events

<p>List audit log events from the Activity module.</p>
<p>Returns events related to</p>
<ul>
<li><p>Blueprint and Library Item creation, updates, and deletions (Create, Update, Delete)</p>
</li>
<li><p>Access to sensitive data (such as FileVault keys and recovery keys)</p>
</li>
<li><p>Device lifecycle events (enrollment, deletion, MDM removal, blueprint changes)</p>
</li>
<li><p>User directory events (including directory user deletions)</p>
</li>
<li><p>Administrative actions (tenant owner updates, API token management (Create, Update, Delete))</p>
</li>
<li><p>Admin user management activities</p>
</li>
<li><p>Vulnerability management events for detections and remediations (for customers with this feature)</p>
</li>
<li><p>Endpoint Detection and Response events for detections, remediations, and admin actions (for customers with this feature)</p>
</li>
</ul>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListAuditEventsRequest
*/
func (a *AuditLogAPIService) ListAuditEvents(ctx context.Context) ApiListAuditEventsRequest {
	return ApiListAuditEventsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AuditLogListAuditEvents200Response
func (a *AuditLogAPIService) ListAuditEventsExecute(r ApiListAuditEventsRequest) (*AuditLogListAuditEvents200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuditLogListAuditEvents200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuditLogAPIService.ListAuditEvents")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/audit/events"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.limit == nil {
		return localVarReturnValue, nil, reportError("limit is required and must be specified")
	}
	if r.sortBy == nil {
		return localVarReturnValue, nil, reportError("sortBy is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", r.sortBy, "form", "")
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
